---
layout: post
title: "锁"
date: 2020-04-15 
---

# “锁”

### Synchronized原理？

这是一道Java面试中几乎百分百会问到的问题，因为没有任何写过并发的开发者会没听或者没接触过`Synchroized`

`Synchroized`是由JVM实现的一种实现互斥同步的一种方式，如果你查看被`Synchronized`修饰过的程序块编译后的字节码，会发现被`Synchronized`修饰过的程序块，在编译前后被编译器生成了`moniternter`和`monitorexit`两个字节码指令。

***这两个指令是什么意思呢？***

​	在虚拟机执行到`moniternter`指令时，首先要尝试获取对象的锁；如果这个对象没有锁定，或者当前线程已经拥有这个对象的锁，把锁的计数器+1；当执行`monitorexit`指令时讲锁计数器-1；当计数器为0时，锁就释放了。

​	如果获取对象失败了，当前线程就要阻塞等待，直到对象锁被另一个线程释放为止。

`Java`中`Synchronized`通过在对象头设置标记，达到获取锁和释放锁的目的。

### 刚才提到获取对象的锁，这个“锁”到底是什么？如何确定对象的锁？

“锁”的本质其实是`moniternter`和`monitorexit`字节码指令的一个`Reference`类型的参数，即要锁定的对象和解锁的对象。我们知道，使用`Synchronized`可以修饰不同的对象，因此，对应的对象锁可以这么确定。

1. 如果`Synchronized`明确指定了锁对象，比如`Synchronized(变量名)`、`Synchronized(this)`等，说明加解锁对象为该对象。

2. 如果没有明确指定：

   * 若`Synchronized`修饰的方法为非静态方法，表示此方法对应的类对象为锁对象。

   * 若`Synchronized`修饰的方法为静态方法，则表示此方法对应的类对象为锁对象。

     **注意！！**   当一个对象被锁住时，对象里面所有用`Synchronized`修饰的方法都将产生阻塞，而对象非`Synchronized`修饰的方法可正常被调用，不受影响。

### 什么是可重入性，为什么说`Synchronized`是可重入锁？

可重入性是锁的一个基本要求，是为了解决自己锁死自己的情况。举例：一个类中的同步方法调用另一个同步方法，假如`Synchronized`不支持重入，进入method2方法时当前线成获得锁，method2方法里面执行method1时当前线程又要去尝试获取锁，这时如果不支持重入，他就要等待释放，把自己阻塞，导致锁死自己。对`Synchronized`来说，可重入性是显而易见的，刚才提到，在执行`monitorenter`指令时，如果这个对象没有锁定，或者当前线程已经拥有了这个对象的锁 **（而不是以拥有了锁则不能继续获取）**，就把锁的计数器+1，其实本质上就通过这种方式实现了可重入性。

### JVM对Java的原生锁做了哪些优化？

在Java6之前，Monitor的实现完全依赖底层操作系统的互斥锁来实现，也就是我们刚才在问题二中所阐述的获取/释放逻辑。

由于Java层面的线程与操作系统的原生线程有映射关系，如果要将一个线程进行阻塞或唤起都需要操作系统的协助，这就需要从用户态切换到内核态来执行，这种切换代价十分昂贵，很耗处理器时间，现在JDK中做了大量的优化。

一种优化是使用自旋锁，即在把线程进行阻塞操作之前先让线程自旋等待一段时间，可能在等待期间其他线程已经解锁，这时就无需再让线程执行阻塞操作，避免了用户态到内核态的切换。

现代JDK中还提供了三种不同的`Monitor`实现，也就是三种不同的锁：

* 偏向锁（Biased Locking）

* 轻量级锁

* 重量级锁

  这三种锁使得JDK得以优化`Synchronized`的运行，当JVM检测到不同的竞争状况时，会自动切换到适合的锁实现，这就是锁的升级、降级。

* 当没有竞争出现时，默认会使用偏向锁

  `JVM会利用CAS操作，在对象头上的Mark Word部分设置线程ID，以表示这个对象偏向于当前线程，所以并不涉及真正的互斥锁门因为很多应用场景中，大部分对象生命周期中最多会被一个线程锁定，使用偏斜锁可以降低无竞争开销。`

  --------

  ----

* 如果有另一线程试图锁定某个被偏斜过的对象，JVM就撤销偏斜锁，切换到轻量级锁实现。

* 轻量级锁以来CAS操作Mark Word来试图获取锁，如果重试成功，就使用普通的轻量级锁；否则，进一步升级为重量级锁。

### 为什么说`Synchronized`是非公平锁？

非公平主要表现在获取锁的行为上，并非是按照申请锁的时间前后给等待线程分配锁的，每当锁被释放后，任何一个线程都有机会竞争到锁，这样做的目的是为了提高执行性能，缺点是可能 会产生线程饥饿现象。

### 什么是锁消除和锁粗化？

* **锁消除**：指虚拟机即时编译器在运行时，对一些代码上要求同步，但被检测到不可能存在共享数据竞争的锁进行消除。主要根据逃逸分析。
* **锁粗化**：原则上，同步块的作用范围要尽量小。但是如果一系列的连续操作都对一个对象反复加锁和解锁，甚至枷锁操作在循环体内，频繁地进行互斥同步操作也会导致不必要的性能损耗。 锁粗化就是增大锁的作用域。

### 为什么说`Synchronized`是一个悲观锁？乐观锁的实现原理又是什么？什么是CAS，它有什么特性？

`Synchronized`显然是一个悲观锁，因为它的并发策略是悲观的：

`不管是否会产生竞争，任何的数据操作都必须要加锁、用户态核心态转换、维护锁计数器和检查是否有被阻塞的线程需要被唤醒等操作。`随着硬件指令集的发展，我们可以使用基于冲突检测的乐观并发策略，先进行操作，如果没有其他线程征用数据，那操作成功了；

​	如果共享数据有征用，产生了冲突，那就再进行其他的补偿措施。这种乐观的并发策略的许多实现不需要线程挂起，所以被称为非阻塞同步。

​	乐观锁的核心算法是`CAS(Compareand Swap, 比较并交换)`，它设计到三个操作数:内存值、预期值、新值。当且仅当内存值相等时才讲内存值修改为新值。这样的处理逻辑是，首先检查某块内存的值是否跟你之前我读区时的一样，如不一样则表示此内存值已经被别的线程更改过，舍弃本次操作块，否则说明期间没有其他线程对此内存值的操作，可以把新值设置给此块内存。

​	`CAS`具有原子性，它的原子性有CPU硬件指令实现保证，即使用`JNI`调用`Native`方法调用用由**C++**编写的硬件级别指令，`JDK`中提供了`Unsafe`类执行这些操作。

### 乐观锁一定就是好的吗？

乐观锁避免了悲观锁独占对象的现象，同时也提高了并发性能，但它也有缺点：

1. 乐观锁只能保证一个共享变量的原子操作。如果多一个或几个变量，乐观锁将变得力不从心，但互斥锁能轻易解决，不管对象数量多少及对象颗粒度大小。
2. 长时间自旋可能导致开销大。加入`CAS`长时间不成功而一直自旋，会给CPU带来很大的开销。
3. ABA问题。`CAS`核心思想是通过比对内存值与预期值是否一样而判断内存是否被改过，但这个判断逻辑不严谨，加入内存值原来是A，后来被一条线程改为B，最后又被改成了A，则CAS认为此内存值并没有发生改变，但实际上是有被其他线程改过的，这种情况对以来过程值的情景运算结果影响很大。解决的思路是引入版本号，每次变量更新都把版本号加一。

### 可重入锁`ReentrantLock`及其他显示锁相关问题

* #### **跟`Synchronized`相比可重入锁`ReentrantLock`其实现原理有什么不同？**

  其实，锁的实现原理基本都是为了达到一个目的：**让所有的线程都能看到某种标记。**

  `Synchronized`通过在对象头中设置标记实现了这一目的，是一种JVM原生的锁的实现方式，而`ReentrantLock`以及所有的给予`Lock`接口的实现类，都是通过用一个`Volitile`修饰的`int`型变量，并保证悲歌线程都能拥有对该`int`的可见性和 原子修改，其本质是基于所有的`AQS`框架。

  ### 什么是`AQS`框架？

  `AQS(AbstractQueuedSynchronizer)`是一个用来构建锁和同步锁的框架，各种`Lock`包中的锁(常用的有    `ReentrantLock`、 `ReadWriteLock`) ， 以 及 其 他 如 `Semaphore`、 `CountDownLatch`， 甚 至是早期的 `FutureTask` 等，都是基于 `AQS` 来构建。

  * `AQS`在内部定义了一个`volatile int state`变量，表示同步状态：当线程调用`lock`方法时，如果`state=0`,说明没有哦任何线程占用共享资源的锁，可以获得锁并将`state=1`；如果`state=1`，则说明又线程目前正在使用共享变量，其他线程必须加入同步队列进行等待。
  * `AQS`通过`Node`内部类构成的一个双向链表结构的不同队列，来完成线程获取锁的排队工作，当有线程获取锁失败后，就被调价到队列末尾。
    * `Node`类是对要访问同步代码的线程的封装，包含了线程本身及其状态叫`waitStatus`(有五种不同去值，分别表示是否被阻塞，是否等待唤醒，是都已经被取消等)，每个`Node`节点关联其`prev`和`next`节点，方便线程释放锁后快速唤醒下一个在等待的线程，是一个`FIFO`的过程。
    * `Node`类有两个常量，`SHARED`和`EXCLUSIVE`，分别代表共享模式和独占模式。所谓共享模式是一个锁允许多条线同时操作（信号量`Semaphore`就是基于`AQS`的共享模式实现的），独占模式是同一个时间段只能有一个线程对共享资源进行操作，多余的请求线程需要排队等待(如`ReentranLock`)。
  * `AQS`通过内部类`ConditionObject`构建等待队列(可有多个)，当`Condition`调用`wait()`方法后，线程会加入等待队列中，而当`Condition`调用`signal()`方法后，线程将从等待队列转移到同步队列中进行锁竞争。
  * `AQS`和`Condition`个字维护了不同的队列，在使用`Lock`和`Condition`的时候，其实就是两个队列的互相移动。

### `Synchronized`和`ReentrantLock`的异同

`ReentrantLock`是Lock的实现类，是一个互斥的同步锁。

从功能监督，`ReentrantLock`比`Synchronized`的同步操作更精细(因为可以像普通对象一样使用)，甚至实现`Synchronized`没有的高级功能，如：

1. **等待可中断 ：**当持有锁的线程长期不释放锁的时候，正在等待的线程可以选择 放弃等待，对处理执行时间非常长的同步块很有用。
2. **带超市的获取锁尝试：**在指定的时间范围内获取锁，如果时间到了 仍然无法获取则返回。
3. **可以判断是否有线程在排队等待获取锁**
4. **可以响应中断请求：**与`Synchronized`在JVM层面上实现的，不但可以通过一些监控工具监控`Synchronzied`的锁定，而且在代码执行出现异常时，JVM会自动释放锁定；但是使用`Lock`则不行，`Lock`时通过代码实现的，要保证锁定一定会被释放，就必须将`unLock()`放到`finally{}`中。

从性能角度，`Synchronized`早起实现比较低效，对比`ReentrantLock`，大多数场景性能都相差较大。但是在Java6中对其进行了非常多的改进，在竞争不激烈时，`Synchronized`的性能要优于`ReentrantLock`；在搞竞争情况下`Synchronized`的性能会下降 几十倍，但是`ReentrantLock`的性能能维持常态。



### `ReentrantLock`是如何实现可重入性的！

`ReentrantLock`内部自定义了同步器`Sync(Synnc及实现了AQS，有实现了AOS，而AOS提供了一种互斥锁持有的方式)`，其实就是加锁的时候通过CAS算法，将线程对象放到一个双向链表中，每次获取锁的时候，看下当前维护的那个线程ID和当前请求的线程ID是否一样，一样就重入了。

### 除了`ReentrantLock`，还接触过JUC`java.util.concurrent`中的那些并发工具？

通常所说的并发包(JUC)也就是`java.util.concurrent`及其子包，集中了Java并发的各种基础工具类，具体主要包括几个方面：

* 提供了`CountDownLatch`、`CycliBarrier`、`Semaphore`等，比`Synchronized`更加高级，可以实现更加丰富多线程操作的同步结构。
* 提供了`ConcurrentHashMap`、有序的`ConcunrrentSkipListMap`或者通过类似快照机制实现线程安全的动态数组`CopyOnWriteArrayList`等，各种线程安全的容器。
* 提供了`ArrayBlockingQueue`、`SynchorousQueue`或针对特定场景的`PriorityBlockingQueue`等，各种并发队列实现。
* 强大的`Executor`框架，可以创建各种不同类型的咸亨吃，调度任务运行等。

### `ReadWriteLock`和`StampedLock`

虽然`ReentrantLock`和`Synchronized`简单实用，但是行为上有一定局限性，要么不占，要么独占。实际应用场景中，有时候不需要大量竞争的写操作，而是以并发读取为主，为了进一步优化并发操作的力度，Java提供了读写锁。

读写锁基于的原理是多个读操作不需要互斥，如果读锁试图锁定时，写锁是被某个线程持有，读锁将无法获得，而只好等待对象操作结束，这样就可以自动保证不会读取到有争议的数据。

`ReadWriteLock`代表了一对锁，下面是一个基于读写锁实现的数据结构，当数据量较大，并发读多，并发写少的时候，能够比出同步版本凸显出优势：

```java
public class RWSample {
    private final Map<String, String> m = new TreeMap<>();
    private final ReentrantReadWriteLock rwl = new ReentrantReadWriteLock();
    private final Lock r = rwl.readLock();
    private final Lock w = rwl.writeLock();

    public String get(String key){
        System.out.println("读锁锁定!");
        try{
            return m.get(key);
        } finally {
            r.unlock();
        }
    }

    public String put(String key, String entry){
        w.lock();;
        System.out.println("写锁锁定!");
        try{
            return m.put(key, entry);
        }  finally {
            w.unlock();
        }
    }
}
```

读写锁看起来比`Synchronized`的粒度似乎细一些，但在实际应用中，其表现也并不尽如人意 ，主要还是因为 相对比较大的恶开销。随意JDK在后期引入了 `StampedLock`，在提供类似读写锁的同时，还支持优化读模式。大多数情况下读操作并不会和写操作冲突，其逻辑是先试着修改，然后通过`validate`方法确认是否进入了写模式，如果没有进入，就成功 避免了开销；如果进入，则尝试 获取读锁。

```java
public class StampedSample{
	private final StampedLock sl = new StampedLock();
  
  void mutate(){
    long stamp = sl.writeLock();
    try{
      write();
    } finally{
      sl.unlockWrite();
    }
  }
  Data access(){
    long stamp = sl.tryOptimisticRead();
    Data data = read();
    if(!sl.validate(stamp)){
      stamp = sk.readLock();
      try{
        data = read();
      } finally{
        sl.unlockRead();
      }
    }
    return data;
  }
}
```

