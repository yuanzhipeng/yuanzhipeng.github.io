---
layout: post
title: "ConcurrentHashMap"
date: 2020-04-16 21:43:24.000000000 +09:00
---

# “**ConcurrentHashMap**”

**`ConcurrentHashMap`**是线程安全的Map，在1.7和1.8中实现有所不同。

* 在JDK1.7中采用分段锁的机制，实现并发的更新操作，底层采用数组+链表的存储结构，包含两个核心静态内部类`Segment`和`HashEntry`。

  1.`Segment`继承`ReentrantLock`(重入锁)用来充当锁的角色，每个`Segment`对象守护每个散列映射表的若干个木桶；

  2.`HashEntry`用来封装映射表的键-值对

  3.每个桶石油若干个`HashEntry`对象链接起来的链表

* 在JDK1.8中，采用** Node + CAS + Synchronized来保证并发安全。取消类`Segment`，直接用table数组存储键值对；当`HashEntry`对象组成的链表长度超过**TREEIFY_THRESHOLD**时，链表转换为红黑树，提升性能。底层变更为数组 + 链表 + 红黑树

  在1.8里

  1.**重要的常量： `private transient volatile int sizeCtl;`**

  ​	当为负数时，-1表示正在初始化，-N表示N-1个线程正在进行扩容

  ​	当为0时，表示table还没有初始化

  ​	当为其他正数时，表示初始化或下一次进行扩容的大小

  2.**数据结构：**

  ​	**Node**是存储结构的基本单元，实现了Map中的`Entry`接口，用于存储数据

  ​	**TreeNode**继承`Node`，但是数据结构转换成了二叉树结构，是红黑树的存储结构，用于红黑树中存储数据

  ​	**TreeBin**是封装`TreeNode`的容器，提供转换红黑树的一些条件和锁的控制

  3.**存储对象是(`put()`方法)：**

  ​	1.如果没有初始化，就调用`initTable()`方法来进行初始化；

  ​	2.如果没有 hash 冲突就直接 CAS 无锁插入;

  ​	3.如果需要扩容，就先进行扩容;

  ​	4.如果存在hash冲突，就加锁来保证线程安全，两种情况：一种是链表形式就直接遍历到尾端插入，一种是红黑树就按照红黑树结构插入；

  ​	5.如果该链表的数量大于阀值 8，就要先转换成红黑树的结构；

  ​	6.如果添加成功就调用 `addCount()` 方法统计 size，并且检查是否需要扩容。

* 扩容方法`transfer()`默认容量为16，扩容时，容量变为原来的两倍；`helpTransfer()`调用多个工作线程一起帮助进行扩容，这样的效率就会更高

* **获取对象时(`get()`方法)：**

  1.计算hash值，定位到该table索引位置，如果是首节点符合就返回；

  2.如果与到扩容时，会调用标记正在扩容节点`ForwardingNode.find()`方法，查找该节点匹配就返回；

  3.以上都不符合的话，就遍历节点，匹配就返回，否则最后就返回null；



### 为什么hashmap 1.8 不直接使用红黑树而还要保留链表

因为插入时红黑树需要进行左旋，右旋操作，而单链表不需要，在数量较少时，红黑树并没有表现出比链表更好的查询效率，而且在占用空间上，红黑树的节点比链表的节点更大，时链表的两倍；



### 为什么大于8 个的时候才转换红黑树

**按照 JDK 源码里解释是这样的:**

`TreeNodes` 占用空间是普通 `Nodes` 的两倍，所以只有当 bin 包含足够多的节点时才会转成`TreeNode`s，而是否足够多就是由` TREEIFY_THRESHOLD` 的值决定的。当 bin 中节点数变少时， 又会转成普通的 bin。`TREEIFY_THRESHOLD` 的值是个空间和时间的权衡。

当 hashCode 离散性很好的时候，树型 bin 用到的概率非常小，因为数据均匀分布在每个 bin 中，几乎不会有 bin 中链表长度会达到阈值。

但是在随机 hashCode 下，离散性可能会变差，然而 JDK 又不能阻止用户实现这种不好的 hash 算法，因此就可能导致不均匀的数据分布。

不过理想情况下随机 hashCode 算法下所有 bin 中节点的分布频率会遵循泊松分布，

一个 bin 中链表长度达到 8 个元素的概率为 0.00000006，几乎是不可能事件。所以，之所 以选择 8，不是拍拍屁股决定的，而是根据概率统计决定的。

**当然网上也有这样的说法:**

红黑树的平均查找长度是 log(n)，如果长度为 8，平均查找长度为 log(8)=3，链表的平均查 找长度为 n/2，当长度为 8 时，平均查找长度为 8/2=4，这才有转换成树的必要;链表长度 如果是小于等于 6，6/2=3，而 log(6)=2.6，虽然速度也很快的，但是转化为树结构和生成树 的时间并不会太短。