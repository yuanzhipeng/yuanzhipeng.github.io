<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title></title>
    <link href="/2020/12/02/2020-05-08-Redis%206.0%20%E5%BC%80%E5%A7%8B%E6%94%AF%E6%8C%81%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%BA%86/"/>
    <url>/2020/12/02/2020-05-08-Redis%206.0%20%E5%BC%80%E5%A7%8B%E6%94%AF%E6%8C%81%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%BA%86/</url>
    
    <content type="html"><![CDATA[<h1 id="Redis-6-0-开始支持多线程了"><a href="#Redis-6-0-开始支持多线程了" class="headerlink" title="Redis 6.0 开始支持多线程了"></a>Redis 6.0 开始支持多线程了</h1><h2 id="1-Redis6-0之前的版本真的是单线程吗？"><a href="#1-Redis6-0之前的版本真的是单线程吗？" class="headerlink" title="1.Redis6.0之前的版本真的是单线程吗？"></a><strong>1.Redis6.0之前的版本真的是单线程吗？</strong></h2><p>Redis在处理客户端的请求时，包括获取 (socket 读)、解析、执行、内容返回 (socket 写) 等都由一个顺序串行的主线程处理，这就是所谓的“单线程”。但如果严格来讲从Redis4.0之后并不是单线程，除了主线程外，它也有后台线程在处理一些较为缓慢的操作，例如清理脏数据、无用连接的释放、大 key 的删除等等。</p><h2 id="2-Redis6-0之前为什么一直不使用多线程？"><a href="#2-Redis6-0之前为什么一直不使用多线程？" class="headerlink" title="2.Redis6.0之前为什么一直不使用多线程？"></a><strong>2.Redis6.0之前为什么一直不使用多线程？</strong></h2><p>官方曾做过类似问题的回复：使用Redis时，几乎不存在CPU成为瓶颈的情况， Redis主要受限于内存和网络。例如在一个普通的Linux系统上，Redis通过使用pipelining每秒可以处理100万个请求，所以如果应用程序主要使用O(N)或O(log(N))的命令，它几乎不会占用太多CPU。</p><p>使用了单线程后，可维护性高。多线程模型虽然在某些方面表现优异，但是它却引入了程序执行顺序的不确定性，带来了并发读写的一系列问题，增加了系统复杂度、同时可能存在线程切换、甚至加锁解锁、死锁造成的性能损耗。Redis通过AE事件模型以及IO多路复用等技术，处理性能非常高，因此没有必要使用多线程。单线程机制使得 Redis 内部实现的复杂度大大降低，Hash 的惰性 Rehash、Lpush 等等 “线程不安全” 的命令都可以无锁进行。</p><h2 id="3-Redis6-0为什么要引入多线程呢？"><a href="#3-Redis6-0为什么要引入多线程呢？" class="headerlink" title="3.Redis6.0为什么要引入多线程呢？"></a><strong>3.Redis6.0为什么要引入多线程呢？</strong></h2><p>Redis将所有数据放在内存中，内存的响应时长大约为100纳秒，对于小数据包，Redis服务器可以处理80,000到100,000 QPS，这也是Redis处理的极限了，对于80%的公司来说，单线程的Redis已经足够使用了。</p><p>但随着越来越复杂的业务场景，有些公司动不动就上亿的交易量，因此需要更大的QPS。常见的解决方案是在分布式架构中对数据进行分区并采用多个服务器，但该方案有非常大的缺点，例如要管理的Redis服务器太多，维护代价大；某些适用于单个Redis服务器的命令不适用于数据分区；数据分区无法解决热点读/写问题；数据偏斜，重新分配和放大/缩小变得更加复杂等等。</p><p>从Redis自身角度来说，因为读写网络的read/write系统调用占用了Redis执行期间大部分CPU时间，瓶颈主要在于网络的 IO 消耗, 优化主要有两个方向:</p><p>  • 提高网络 IO 性能，典型的实现比如使用 DPDK 来替代内核网络栈的方式</p><p>  • 使用多线程充分利用多核，典型的实现比如 Memcached。</p><p>协议栈优化的这种方式跟 Redis 关系不大，支持多线程是一种最有效最便捷的操作方式。所以总结起来，redis支持多线程主要就是两个原因：</p><p>  • 可以充分利用服务器 CPU 资源，目前主线程只能利用一个核</p><p>  • 多线程任务可以分摊 Redis 同步 IO 读写负荷</p><h2 id="4-Redis6-0默认是否开启了多线程？"><a href="#4-Redis6-0默认是否开启了多线程？" class="headerlink" title="4.Redis6.0默认是否开启了多线程？"></a><strong>4.Redis6.0默认是否开启了多线程？</strong></h2><p>Redis6.0的多线程默认是禁用的，只使用主线程。如需开启需要修改redis.conf配置文件：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">io-threads-<span class="hljs-keyword">do</span>-reads yes<br></code></pre></td></tr></table></figure><h2 id="5-Redis6-0多线程开启时，线程数如何设置？"><a href="#5-Redis6-0多线程开启时，线程数如何设置？" class="headerlink" title="5.Redis6.0多线程开启时，线程数如何设置？"></a><strong>5.Redis6.0多线程开启时，线程数如何设置？</strong></h2><p>开启多线程后，还需要设置线程数，否则是不生效的。同样修改redis.conf配置文件 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">io-threads <span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><p>关于线程数的设置，官方有一个建议：4核的机器建议设置为2或3个线程，8核的建议设置为6个线程，线程数一定要小于机器核数。还需要注意的是，线程数并不是越大越好，官方认为超过了8个基本就没什么意义了。</p><h2 id="6-Redis6-0采用多线程后，性能的提升效果如何？"><a href="#6-Redis6-0采用多线程后，性能的提升效果如何？" class="headerlink" title="6.Redis6.0采用多线程后，性能的提升效果如何？"></a><strong>6.Redis6.0采用多线程后，性能的提升效果如何？</strong></h2><p>Redis 作者 antirez 在 RedisConf 2019分享时曾提到：Redis 6 引入的多线程 IO 特性对性能提升至少是一倍以上。国内也有大牛曾使用unstable版本在阿里云esc进行过测试，GET/SET 命令在4线程 IO时性能相比单线程是几乎是翻倍了。</p><p><a href="*https://zhuanlan.zhihu.com/p/76788470*">测试详见</a></p><p><strong>说明1</strong>：这些性能验证的测试并没有针对严谨的延时控制和不同并发的场景进行压测。数据仅供验证参考而不能作为线上指标。</p><p><strong>说明2</strong>：如果开启多线程，至少要4核的机器，且Redis实例已经占用相当大的CPU耗时的时候才建议采用，否则使用多线程没有意义。所以估计80%的公司开发人员看看就好。</p><h2 id="7-Redis6-0多线程的实现机制？"><a href="#7-Redis6-0多线程的实现机制？" class="headerlink" title="7.Redis6.0多线程的实现机制？"></a><strong>7.Redis6.0多线程的实现机制？</strong></h2><p><strong>流程简述如下：</strong></p><p>1、主线程负责接收建立连接请求，获取 socket 放入全局等待读处理队列</p><p>2、主线程处理完读事件之后，通过 RR(Round Robin) 将这些连接分配给这些 IO 线程</p><p>3、主线程阻塞等待 IO 线程读取 socket 完毕</p><p>4、主线程通过单线程的方式执行请求命令，请求数据读取并解析完成，但并不执行</p><p>5、主线程阻塞等待 IO 线程将数据回写 socket 完毕</p><p>6、解除绑定，清空等待队列</p><p><strong>该设计有如下特点：</strong></p><p>1、IO 线程要么同时在读 socket，要么同时在写，不会同时读或写</p><p>2、IO 线程只负责读写 socket 解析命令，不负责命令处理</p><h2 id="8-开启多线程后，是否会存在线程并发安全问题？"><a href="#8-开启多线程后，是否会存在线程并发安全问题？" class="headerlink" title="8.开启多线程后，是否会存在线程并发安全问题？"></a><strong>8.开启多线程后，是否会存在线程并发安全问题？</strong></h2><p>从上面的实现机制可以看出，Redis的多线程部分只是用来处理网络数据的读写和协议解析，执行命令仍然是单线程顺序执行。所以我们不需要去考虑控制 key、lua、事务，LPUSH/LPOP 等等的并发及线程安全问题。</p><h2 id="9-Linux环境上如何安装Redis6-0-1（6-0的正式版是6-0-1）？"><a href="#9-Linux环境上如何安装Redis6-0-1（6-0的正式版是6-0-1）？" class="headerlink" title="9.Linux环境上如何安装Redis6.0.1（6.0的正式版是6.0.1）？"></a><strong>9.Linux环境上如何安装Redis6.0.1（6.0的正式版是6.0.1）？</strong></h2><p>这个和安装其他版本的redis没有任何区别，整个流程跑下来也没有任何的坑，所以这里就不做描述了。唯一要注意的就是配置多线程数一定要小于cpu的核心数，查看核心数量命令：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">[root@centos7.5 ~]# lscpuArchitecture: x86_64CPU op-mode(s): 32-bit, 64-bitByte Order: Little EndianCPU(s): 4On-line CPU(s) list: 0-3<br></code></pre></td></tr></table></figure><h2 id="10-Redis6-0的多线程和Memcached多线程模型进行对比"><a href="#10-Redis6-0的多线程和Memcached多线程模型进行对比" class="headerlink" title="10.Redis6.0的多线程和Memcached多线程模型进行对比"></a><strong>10.Redis6.0的多线程和Memcached多线程模型进行对比</strong></h2><p>前些年memcached 是各大互联网公司常用的缓存方案，因此redis 和 memcached 的区别基本成了面试官缓存方面必问的面试题，最近几年memcached用的少了，基本都是 redis。不过随着Redis6.0加入了多线程特性，类似的问题可能还会出现，接下来我们只针对多线程模型来简单比较一下。</p><p>Memcached 服务器采用 master-woker 模式进行工作，服务端采用 socket 与客户端通讯。主线程、工作线程 采用 pipe管道进行通讯。主线程采用 libevent 监听 listen、accept 的读事件，事件响应后将连接信息的数据结构封装起来，根据算法选择合适的工作线程，将连接任务携带连接信息分发出去，相应的线程利用连接描述符建立与客户端的socket连接 并进行后续的存取数据操作。</p><p>Redis6.0与Memcached多线程模型对比：</p><p><strong>相同点：</strong>都采用了 master线程-worker 线程的模型</p><p><strong>不同点</strong>：Memcached 执行主逻辑也是在 worker 线程里，模型更加简单，实现了真正的线程隔离，符合我们对线程隔离的常规理解。而 Redis 把处理逻辑交还给 master 线程，虽然一定程度上增加了模型复杂度，但也解决了线程并发安全等问题。</p><h2 id="11-Redis作者是如何点评-“多线程”这个新特性的？"><a href="#11-Redis作者是如何点评-“多线程”这个新特性的？" class="headerlink" title="11.Redis作者是如何点评 “多线程”这个新特性的？"></a><strong>11.Redis作者是如何点评 “多线程”这个新特性的？</strong></h2><p>关于多线程这个特性，在6.0 RC1时，Antirez曾做过说明：</p><p>Redis支持多线程有2种可行的方式：第一种就是像“memcached”那样，一个Redis实例开启多个线程，从而提升GET/SET等简单命令中每秒可以执行的操作。这涉及到I/O、命令解析等多线程处理，因此，我们将其称之为“I/O threading”。另一种就是允许在不同的线程中执行较耗时较慢的命令，以确保其它客户端不被阻塞，我们将这种线程模型称为“Slow commands threading”。</p><p>经过深思熟虑，Redis不会采用“I/O threading”，redis在运行时主要受制于网络和内存，所以提升redis性能主要是通过在多个redis实例，特别是redis集群。接下来我们主要会考虑改进两个方面：</p><p>\1. Redis集群的多个实例通过编排能够合理地使用本地实例的磁盘，避免同时重写AOF。</p><p>2.提供一个Redis集群代理，便于用户在没有较好的集群协议客户端时抽象出一个集群。</p><p>补充说明一下，Redis和memcached一样是一个内存系统，但不同于Memcached。多线程是复杂的，必须考虑使用简单的数据模型，执行LPUSH的线程需要服务其他执行LPOP的线程。</p><p>我真正期望的实际是“slow operations threading”，在redis6或redis7中，将提供“key-level locking”，使得线程可以完全获得对键的控制以处理缓慢的操作。</p><p><a href="http://antirez.com/news/126">详见</a></p><h2 id="12-Redis线程中经常提到IO多路复用，如何理解？"><a href="#12-Redis线程中经常提到IO多路复用，如何理解？" class="headerlink" title="12.Redis线程中经常提到IO多路复用，如何理解？"></a><strong>12.Redis线程中经常提到IO多路复用，如何理解？</strong></h2><p>这是IO模型的一种，即经典的Reactor设计模式，有时也称为异步阻塞IO。</p><p>多路指的是多个socket连接，复用指的是复用一个线程。多路复用主要有三种技术：select，poll，epoll。epoll是最新的也是目前最好的多路复用技术。采用多路 I/O 复用技术可以让单个线程高效的处理多个连接请求（尽量减少网络IO的时间消耗），且Redis在内存中操作数据的速度非常快（内存内的操作不会成为这里的性能瓶颈），主要以上两点造就了Redis具有很高的吞吐量。</p><p><strong>参考</strong></p><p><a href="https://mp.weixin.qq.com/s/B-4ei2yfAT17DDKQRu2NXg">https://mp.weixin.qq.com/s/B-4ei2yfAT17DDKQRu2NXg</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2020/12/02/2020-05-02-SpringBoot%E5%AD%A6%E4%B9%A0(%E4%BA%8C)%E3%80%81%E5%BC%95%E5%85%A5mybatis/"/>
    <url>/2020/12/02/2020-05-02-SpringBoot%E5%AD%A6%E4%B9%A0(%E4%BA%8C)%E3%80%81%E5%BC%95%E5%85%A5mybatis/</url>
    
    <content type="html"><![CDATA[<h1 id="SpringBoot-引入MyBatis"><a href="#SpringBoot-引入MyBatis" class="headerlink" title="SpringBoot 引入MyBatis"></a>SpringBoot 引入MyBatis</h1><p>整合MyBatis之前，先搭建一个基本的SpringBoot项目，<a href="%5Bhttp://sybx.cc/2020/05/SpringBoot%E5%AD%A6%E4%B9%A0(%E4%B8%80)/%5D(http://sybx.cc/2020/05/SpringBoot%E5%AD%A6%E4%B9%A0(%E4%B8%80)/)%E3%80%82%E7%84%B6%E5%90%8E%E5%BC%95%E5%85%A5mybatis-spring-boot-start%E5%92%8C%E6%95%B0%E6%8D%AE%E8%BF%9E%E6%8E%A5%E9%A9%B1%E5%8A%A8(MySQL:5.7">springBoot基本配置</a></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;!-- 引入mybatis框架 --&gt;<br>&lt;dependency&gt;<br>    &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;<br>    &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;<br>    &lt;version&gt;1.3.1&lt;/version&gt;<br>&lt;/dependency&gt;<br><br>&lt;!-- 引入mysql驱动 --&gt;<br>&lt;dependency&gt;<br>    &lt;groupId&gt;mysql&lt;/groupId&gt;<br>    &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;<br>    &lt;scope&gt;runtime&lt;/scope&gt;<br>&lt;/dependency&gt;<br></code></pre></td></tr></table></figure><h2 id="Druid数据源"><a href="#Druid数据源" class="headerlink" title="Druid数据源"></a>Druid数据源</h2><p>Druid是一个关系型数据库连接池，是阿里巴巴的一个开源项目，地址：<a href="https://github.com/alibaba/druid%E3%80%82Druid%E4%B8%8D%E4%BD%86%E6%8F%90%E4%BE%9B%E8%BF%9E%E6%8E%A5%E6%B1%A0%E7%9A%84%E5%8A%9F%E8%83%BD%EF%BC%8C%E8%BF%98%E6%8F%90%E4%BE%9B%E7%9B%91%E6%8E%A7%E5%8A%9F%E8%83%BD%EF%BC%8C%E5%8F%AF%E4%BB%A5%E5%AE%9E%E6%97%B6%E6%9F%A5%E7%9C%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0%E5%92%8CSQL%E6%9F%A5%E8%AF%A2%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%83%85%E5%86%B5%E3%80%82">https://github.com/alibaba/druid。Druid不但提供连接池的功能，还提供监控功能，可以实时查看数据库连接池和SQL查询的工作情况。</a></p><p>配置Druid：</p><ul><li>引入Druid</li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;!-- 引入Druid --&gt;<br>&lt;dependency&gt;<br>    &lt;groupId&gt;com.alibaba&lt;/groupId&gt;<br>    &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt;<br>    &lt;version&gt;1.1.10&lt;/version&gt;<br>&lt;/dependency&gt;<br></code></pre></td></tr></table></figure><ul><li>配置文件</li></ul><p>mybatis starter的隐性依赖发现，Spring Boot的数据源配置的默认类型是<code>org.apache.tomcat.jdbc.pool.Datasource</code>，为了使用Druid连接池，需要在application.properties下配置:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs java">## 测试环境 dev profile<br>server:<br>  port: <span class="hljs-number">8081</span><br>  servlet:<br>    context-path: /web<br><br>## Druid 配置<br>spring:<br>  datasource:<br>    druid:<br>      ## 数据库访问配置,使用druid数据源<br>      type: com.alibaba.druid.pool.DruidDataSource<br>      driver-class-name: com.mysql.jdbc.Driver<br>      url: jdbc:mysql:<span class="hljs-comment">//127.0.0.1:3306/operaton?useUnicode=true&amp;characterEncoding=UTF-8&amp;allowMultiQueries=true&amp;autoReconnect=true&amp;failOverReadOnly=false</span><br>      username: root<br>      password: <span class="hljs-number">123456</span><br>      # 连接池配置<br>      initial-size: <span class="hljs-number">5</span><br>      min-idle: <span class="hljs-number">5</span><br>      max-active: <span class="hljs-number">20</span><br>      # 连接等待超时时间<br>      max-wait: <span class="hljs-number">30000</span><br>      # 配置检测可以关闭的空闲连接间隔时间<br>      time-between-eviction-runs-millis: <span class="hljs-number">60000</span><br>      # 配置连接在池中的最小生存时间<br>      min-evictable-idle-time-millis: <span class="hljs-number">300000</span><br>      validation-query: select <span class="hljs-string">&#x27;1&#x27;</span> from dual<br>      test-<span class="hljs-keyword">while</span>-idle: <span class="hljs-keyword">true</span><br>      test-on-borrow: <span class="hljs-keyword">false</span><br>      test-on-<span class="hljs-keyword">return</span>: <span class="hljs-keyword">false</span><br>      # 打开PSCache，并且指定每个连接上PSCache的大小<br>      pool-prepared-statements: <span class="hljs-keyword">true</span><br>      max-open-prepared-statements: <span class="hljs-number">20</span><br>      max-pool-prepared-statement-per-connection-size: <span class="hljs-number">20</span><br>      # 配置监控统计拦截的filters, 去掉后监控界面sql无法统计, &#x27;wall&#x27;用于防火墙<br>      filters: stat,wall<br>      # Spring监控AOP切入点，如x.y.z.service.*,配置多个英文逗号分隔<br>      aop-patterns: com.springboot.yzp.servie.*<br><br>      # WebStatFilter配置<br>      web-stat-filter:<br>        enabled: <span class="hljs-keyword">true</span><br>        # 添加过滤规则<br>        url-pattern: <span class="hljs-comment">/*</span><br><span class="hljs-comment">        # 忽略过滤的格式</span><br><span class="hljs-comment">        exclusions: &#x27;*.js,*.gif,*.jpg,*.png,*.css,*.ico,/druid/*&#x27;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">      # StatViewServlet配置</span><br><span class="hljs-comment">      stat-view-servlet:</span><br><span class="hljs-comment">        enabled: true</span><br><span class="hljs-comment">        # 访问路径为/druid时，跳转到StatViewServlet</span><br><span class="hljs-comment">        url-pattern: /druid/*</span><br><span class="hljs-comment">        # 是否能够重置数据</span><br><span class="hljs-comment">        reset-enable: false</span><br><span class="hljs-comment">        # 需要账号密码才能访问控制台</span><br><span class="hljs-comment">        login-username: sybx</span><br><span class="hljs-comment">        login-password: sybx123</span><br><span class="hljs-comment">        # IP白名单</span><br><span class="hljs-comment">        # allow: 127.0.0.1</span><br><span class="hljs-comment">        #　IP黑名单（共同存在时，deny优先于allow）</span><br><span class="hljs-comment">        # deny: 192.168.31.149</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">      # 配置StatFilter</span><br><span class="hljs-comment">      filter:</span><br><span class="hljs-comment">        stat:</span><br><span class="hljs-comment">          log-slow-sql: true</span><br></code></pre></td></tr></table></figure><p>上述配置不但配置了Druid作为连接池，而且还开启了Druid的监控功能。 其他配置可参考官方wiki——<a href="https://github.com/alibaba/druid/tree/master/druid-spring-boot-starter">https://github.com/alibaba/druid/tree/master/druid-spring-boot-starter</a></p><p>此时，运行项目，访问<a href="http://localhost:8081/web/druid">http://localhost:8081/web/druid</a></p><p>![截屏2020-05-02 下午8.56.21](./截屏2020-05-02 下午8.56.21.png)</p><p>输入账号密码即可登陆Druid监控后台：</p><p>![截屏2020-05-02 下午8.56.30](./截屏2020-05-02 下午8.56.30.png)</p><p>关于Druid的更多说明，可查看官方wiki——<a href="https://github.com/alibaba/druid/wiki/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98">https://github.com/alibaba/druid/wiki/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98</a></p><h2 id=""><a href="#" class="headerlink" title=""></a></h2><p>使用MyBatis</p><p>接下来创建 entity、mapper、service、controller、db-sql</p><p>可以在Druid的控制台上查看SQL监情况；</p><p>![截屏2020-05-02 下午8.56.30](截屏2020-05-02 下午8.56.30.png)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Source：https:<span class="hljs-comment">//github.com/yuanzhipeng/SpringBoot-yzp</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2020/12/02/2020-05-08-MyBatis%E6%BA%90%E7%A0%81%E7%BB%93%E6%9E%84%E8%AF%B4%E6%98%8E/"/>
    <url>/2020/12/02/2020-05-08-MyBatis%E6%BA%90%E7%A0%81%E7%BB%93%E6%9E%84%E8%AF%B4%E6%98%8E/</url>
    
    <content type="html"><![CDATA[<h1 id="MyBatis源码结构说明"><a href="#MyBatis源码结构说明" class="headerlink" title="MyBatis源码结构说明"></a>MyBatis源码结构说明</h1><h2 id="阅读MyBatis源码时可以借助本文档快速查阅相应的包"><a href="#阅读MyBatis源码时可以借助本文档快速查阅相应的包" class="headerlink" title="阅读MyBatis源码时可以借助本文档快速查阅相应的包"></a>阅读MyBatis源码时可以借助本文档快速查阅相应的包</h2><ul><li><p>org.apache.ibatis.annotations</p><ul><li>包含所有mapper接口中用到的注解。例如常用的@Param、@Update、@Select、@Delete</li></ul></li><li><p>org.apache.ibatis.binding</p><ul><li>生成mapper接口的动态代理并进行管理</li></ul></li><li><p>org.apache.ibatis.builder</p><ul><li>包含Configuration对象所有构建器，主要包括XML、注解2中方式配置解析</li><li>BaseBuilder构建器基类</li><li>XMLConfigBuilder解析Configuration.xml配置文件</li><li>XMLMapperBuilder解析Mapper.xml配置文件</li><li>XMLStatementBuilder解析select、update、delete标签</li><li>MapperAnnotationBuilder注解式Mapper</li></ul></li><li><p>org.apache.ibatis.cache</p><ul><li>缓存功能实现、包涵各种缓存装饰器</li><li>TransactionalCache二级缓存功能实现</li></ul></li><li><p>org.apache.ibatis.cursor</p><ul><li>实现游标的方式查询数据、游标非常适合处理百万级别的数据查询，通常情况下不适合一次性加载到内存中，这种方式类似使用SAX解析XML文件</li></ul></li><li><p>org.apache.ibatis.datasource</p><ul><li>数据源包括jndi数据源、连接池功能</li></ul></li><li><p>org.apache.ibatis.executor</p><ul><li>包含SQL语句执行器，核心功能包</li><li>ErrorContext错误上下文对象，跟踪所有执行流程</li><li>主要功能包括<ul><li>主键生成功能</li><li>执行餐睡解析功能</li><li>执行结果集解析功能</li><li>SQL执行器</li><li>缓存执行器</li></ul></li></ul></li><li><p>org.apache.ibatis.exceptions</p><ul><li>框架异常，常见异常：TooManyResultsException</li></ul></li><li><p>org.apache.ibatis.io</p><ul><li>资源文件读取</li></ul></li><li><p>org.apache.ibatis.jdbc</p><ul><li>JDBC一些操作</li><li>SqlRunner SQL执行</li><li>ScriptRunner简本执行，可以执行建库语句，在执行测试用例时候用的非常多</li></ul></li><li><p>org.apache.ibatis.lang</p><ul><li>这个包直邮两个注解@UsesJava7、@UsesJava8使用这两个注解标识哪些可以使用JDK7 API，哪些可以使用JDK8 API</li></ul></li><li><p>org.apache.ibatis.logging</p><ul><li>日志功能，实现多种日志框架的对接</li><li>org.apache.ibatis.logging.jdbc代理所有功能JDBC操作，实现了在debug模式下能够输出SQL</li></ul></li><li><p>org.apache.ibatis.mapping</p><ul><li>配置文件与实体对象的映射功能，Mapper映射、参数映射、结果映射等</li></ul></li><li><p>org.apache.ibatis.parsing</p><ul><li>解析工具包</li><li>GenericTokenParser：解析#{}、${}这种占位符</li><li>XPathParser：XPath形式解析XML</li><li>PropertyParser：properties解析器</li><li>org.apache.ibatis.plugin</li></ul></li><li><p>org.apache.ibatis.plugin</p><ul><li>拦截器功能实现，使用代理模式实现拦截</li></ul></li><li><p>org.apache.ibatis.reflection</p><ul><li>反射器功能，这个包下实现元数据编程</li><li>通过把JAVA对象转换成元数据对象MetaObject，然后就可以把对元数据进行赋值操作，数据库查询结果到Java对象映射就是用过元对象实现</li></ul></li><li><p>org.apache.ibatis.scription</p><ul><li>动态SQL语言实现，配置文件中<if>、<weher>、<set>、<foreach>、<choose>功能就是在这个包实现，借助OGNL表达式，你也可以拓展自己的语言实现功能</li></ul></li><li><p>org.apache.ibatis.session</p><ul><li>主要实现SqlSession功能，非常核心包</li><li>官方注释：SqlSession包涵了MyBatis工作的所有的Java接口，通过这些接口你可以执行SQL命令(select\insert\update\delete)，获取Mapper，管理事务</li></ul></li><li><p>org.apache.ibatis.transaction</p><ul><li>事务功能实现，包装了数据库链接，处理数据库连接</li><li>生命周期包括：连接创建，预编译，提交、回滚和关闭</li></ul></li><li><p>org.apache.ibatis.type</p><ul><li>类型处理器，包括所有数据库类型对应Java类型的处理器，如果要实现自己类型处理器就需要实现包下的基础接口</li></ul></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2020/12/02/2020-05-02-SpringBoot%E5%AD%A6%E4%B9%A0(%E4%B8%80)/"/>
    <url>/2020/12/02/2020-05-02-SpringBoot%E5%AD%A6%E4%B9%A0(%E4%B8%80)/</url>
    
    <content type="html"><![CDATA[<h1 id="SpringBoot的基本配置"><a href="#SpringBoot的基本配置" class="headerlink" title="SpringBoot的基本配置"></a>SpringBoot的基本配置</h1><p><em>默认大家已经是会新建SpringBoot项目(idea新建或者通过<a href="https://start.spring.io/">https://start.spring.io/</a></em></p><h2 id="定制Banner"><a href="#定制Banner" class="headerlink" title="定制Banner"></a>定制Banner</h2><p><strong>SpringBoot项目在启动的时候会有一个默认的启动图案：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">  .   ____          _            __ _ _<br> /\\ / ___<span class="hljs-string">&#x27;_ __ _ _(_)_ __  __ _ \ \ \ \</span><br><span class="hljs-string">( ( )\___ | &#x27;</span>_ | <span class="hljs-string">&#x27;_| | &#x27;</span>_ \/ _` | \ \ \ \<br> \\/  ___)| |_)| | | | | || (_| |  ) ) ) )<br>  <span class="hljs-string">&#x27;  |____| .__|_| |_|_| |_\__, | / / / /</span><br><span class="hljs-string"> =========|_|==============|___/=/_/_/_/</span><br><span class="hljs-string"> :: Spring Boot ::        (v2.2.6.RELEASE)</span><br></code></pre></td></tr></table></figure><p>我们可以把这个图案修改为我们自己想要的。在src/main/sources目录下心间banner.txt文件，然后讲自己的图案粘贴进去即可。ASCII图案可以通过网站一键生成，比如输入“s y b x” 生成图案后复制到banner.txt启动项目，控制台输出如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java">/Library/Java/JavaVirtualMachines/jdk1<span class="hljs-number">.8</span><span class="hljs-number">.0_241</span>.jdk/Contents/Home/bin/java -XX:TieredStopAtLevel=<span class="hljs-number">1</span> -noverify -Dspring.output.ansi.enabled=always -Dcom.sun.management.jmxremote -Dspring.jmx.enabled=<span class="hljs-keyword">true</span> -Dspring.liveBeansView.mbeanDomain -Dspring.application.admin.enabled=<span class="hljs-keyword">true</span> -javaagent:/Applications/IntelliJ IDEA.app/Contents/lib/idea_rt.jar=<span class="hljs-number">53970</span>:/Applications/IntelliJ IDEA.app/Contents/bin -Dfile.encoding=UTF-<span class="hljs-number">8</span> -classpath /Library/Java/JavaVirtualMachines/jdk1<span class="hljs-number">.8</span><span class="hljs-number">.0_241</span>.jdk/Contents/Home/jre/lib/charsets.jar:/Library/Java/JavaVirtualMachines/jdk1<span class="hljs-number">.8</span><span class="hljs-number">.0_241</span>.jdk/Contents/Home/jre/lib/deploy.jar:/Library/Java/JavaVirtualMachines/jdk1<span class="hljs-number">.8</span><span class="hljs-number">.0_241</span>.jdk/Contents/Home/jre/lib/ext/cldrdata.jar:/Library/Java/JavaVirtualMachines/jdk1<span class="hljs-number">.8</span><span class="hljs-number">.0_241</span>.jdk/Contents/Home/jre/lib/ext/dnsns.jar:/Library/Java/JavaVirtualMachines/jdk1<span class="hljs-number">.8</span><span class="hljs-number">.0_241</span>.jdk/Contents/Home/jre/lib/ext/jaccess.jar:/Library/Java/JavaVirtualMachines/jdk1<span class="hljs-number">.8</span><span class="hljs-number">.0_241</span>.jdk/Contents/Home/jre/lib/ext/jfxrt.jar:/Library/Java/JavaVirtualMachines/jdk1<span class="hljs-number">.8</span><span class="hljs-number">.0_241</span>.jdk/Contents/Home/jre/lib/ext/localedata.jar:/Library/Java/JavaVirtualMachines/jdk1<span class="hljs-number">.8</span><span class="hljs-number">.0_241</span>.jdk/Contents/Home/jre/lib/ext/nashorn.jar:/Library/Java/JavaVirtualMachines/jdk1<span class="hljs-number">.8</span><span class="hljs-number">.0_241</span>.jdk/Contents/Home/jre/lib/ext/sunec.jar:/Library/Java/JavaVirtualMachines/jdk1<span class="hljs-number">.8</span><span class="hljs-number">.0_241</span>.jdk/Contents/Home/jre/lib/ext/sunjce_provider.jar:/Library/Java/JavaVirtualMachines/jdk1<span class="hljs-number">.8</span><span class="hljs-number">.0_241</span>.jdk/Contents/Home/jre/lib/ext/sunpkcs11.jar:/Library/Java/JavaVirtualMachines/jdk1<span class="hljs-number">.8</span><span class="hljs-number">.0_241</span>.jdk/Contents/Home/jre/lib/ext/zipfs.jar:/Library/Java/JavaVirtualMachines/jdk1<span class="hljs-number">.8</span><span class="hljs-number">.0_241</span>.jdk/Contents/Home/jre/lib/javaws.jar:/Library/Java/JavaVirtualMachines/jdk1<span class="hljs-number">.8</span><span class="hljs-number">.0_241</span>.jdk/Contents/Home/jre/lib/jce.jar:/Library/Java/JavaVirtualMachines/jdk1<span class="hljs-number">.8</span><span class="hljs-number">.0_241</span>.jdk/Contents/Home/jre/lib/jfr.jar:/Library/Java/JavaVirtualMachines/jdk1<span class="hljs-number">.8</span><span class="hljs-number">.0_241</span>.jdk/Contents/Home/jre/lib/jfxswt.jar:/Library/Java/JavaVirtualMachines/jdk1<span class="hljs-number">.8</span><span class="hljs-number">.0_241</span>.jdk/Contents/Home/jre/lib/jsse.jar:/Library/Java/JavaVirtualMachines/jdk1<span class="hljs-number">.8</span><span class="hljs-number">.0_241</span>.jdk/Contents/Home/jre/lib/management-agent.jar:/Library/Java/JavaVirtualMachines/jdk1<span class="hljs-number">.8</span><span class="hljs-number">.0_241</span>.jdk/Contents/Home/jre/lib/plugin.jar:/Library/Java/JavaVirtualMachines/jdk1<span class="hljs-number">.8</span><span class="hljs-number">.0_241</span>.jdk/Contents/Home/jre/lib/resources.jar:/Library/Java/JavaVirtualMachines/jdk1<span class="hljs-number">.8</span><span class="hljs-number">.0_241</span>.jdk/Contents/Home/jre/lib/rt.jar:/Library/Java/JavaVirtualMachines/jdk1<span class="hljs-number">.8</span><span class="hljs-number">.0_241</span>.jdk/Contents/Home/lib/ant-javafx.jar:/Library/Java/JavaVirtualMachines/jdk1<span class="hljs-number">.8</span><span class="hljs-number">.0_241</span>.jdk/Contents/Home/lib/dt.jar:/Library/Java/JavaVirtualMachines/jdk1<span class="hljs-number">.8</span><span class="hljs-number">.0_241</span>.jdk/Contents/Home/lib/javafx-mx.jar:/Library/Java/JavaVirtualMachines/jdk1<span class="hljs-number">.8</span><span class="hljs-number">.0_241</span>.jdk/Contents/Home/lib/jconsole.jar:/Library/Java/JavaVirtualMachines/jdk1<span class="hljs-number">.8</span><span class="hljs-number">.0_241</span>.jdk/Contents/Home/lib/packager.jar:/Library/Java/JavaVirtualMachines/jdk1<span class="hljs-number">.8</span><span class="hljs-number">.0_241</span>.jdk/Contents/Home/lib/sa-jdi.jar:/Library/Java/JavaVirtualMachines/jdk1<span class="hljs-number">.8</span><span class="hljs-number">.0_241</span>.jdk/Contents/Home/lib/tools.jar:/Users/yuanzhipeng/idea/SpringBoot-yzp/springboot-yzp/target/classes:/Users/yuanzhipeng/.m2/repository/org/springframework/boot/spring-boot-starter-web/<span class="hljs-number">2.2</span><span class="hljs-number">.6</span>.RELEASE/spring-boot-starter-web-<span class="hljs-number">2.2</span><span class="hljs-number">.6</span>.RELEASE.jar:/Users/yuanzhipeng/.m2/repository/org/springframework/boot/spring-boot-starter/<span class="hljs-number">2.2</span><span class="hljs-number">.6</span>.RELEASE/spring-boot-starter-<span class="hljs-number">2.2</span><span class="hljs-number">.6</span>.RELEASE.jar:/Users/yuanzhipeng/.m2/repository/org/springframework/boot/spring-boot/<span class="hljs-number">2.2</span><span class="hljs-number">.6</span>.RELEASE/spring-boot-<span class="hljs-number">2.2</span><span class="hljs-number">.6</span>.RELEASE.jar:/Users/yuanzhipeng/.m2/repository/org/springframework/boot/spring-boot-autoconfigure/<span class="hljs-number">2.2</span><span class="hljs-number">.6</span>.RELEASE/spring-boot-autoconfigure-<span class="hljs-number">2.2</span><span class="hljs-number">.6</span>.RELEASE.jar:/Users/yuanzhipeng/.m2/repository/org/springframework/boot/spring-boot-starter-logging/<span class="hljs-number">2.2</span><span class="hljs-number">.6</span>.RELEASE/spring-boot-starter-logging-<span class="hljs-number">2.2</span><span class="hljs-number">.6</span>.RELEASE.jar:/Users/yuanzhipeng/.m2/repository/ch/qos/logback/logback-classic/<span class="hljs-number">1.2</span><span class="hljs-number">.3</span>/logback-classic-<span class="hljs-number">1.2</span><span class="hljs-number">.3</span>.jar:/Users/yuanzhipeng/.m2/repository/ch/qos/logback/logback-core/<span class="hljs-number">1.2</span><span class="hljs-number">.3</span>/logback-core-<span class="hljs-number">1.2</span><span class="hljs-number">.3</span>.jar:/Users/yuanzhipeng/.m2/repository/org/apache/logging/log4j/log4j-to-slf4j/<span class="hljs-number">2.12</span><span class="hljs-number">.1</span>/log4j-to-slf4j-<span class="hljs-number">2.12</span><span class="hljs-number">.1</span>.jar:/Users/yuanzhipeng/.m2/repository/org/apache/logging/log4j/log4j-api/<span class="hljs-number">2.12</span><span class="hljs-number">.1</span>/log4j-api-<span class="hljs-number">2.12</span><span class="hljs-number">.1</span>.jar:/Users/yuanzhipeng/.m2/repository/org/slf4j/jul-to-slf4j/<span class="hljs-number">1.7</span><span class="hljs-number">.30</span>/jul-to-slf4j-<span class="hljs-number">1.7</span><span class="hljs-number">.30</span>.jar:/Users/yuanzhipeng/.m2/repository/jakarta/annotation/jakarta.annotation-api/<span class="hljs-number">1.3</span><span class="hljs-number">.5</span>/jakarta.annotation-api-<span class="hljs-number">1.3</span><span class="hljs-number">.5</span>.jar:/Users/yuanzhipeng/.m2/repository/org/yaml/snakeyaml/<span class="hljs-number">1.25</span>/snakeyaml-<span class="hljs-number">1.25</span>.jar:/Users/yuanzhipeng/.m2/repository/org/springframework/boot/spring-boot-starter-json/<span class="hljs-number">2.2</span><span class="hljs-number">.6</span>.RELEASE/spring-boot-starter-json-<span class="hljs-number">2.2</span><span class="hljs-number">.6</span>.RELEASE.jar:/Users/yuanzhipeng/.m2/repository/com/fasterxml/jackson/core/jackson-databind/<span class="hljs-number">2.10</span><span class="hljs-number">.3</span>/jackson-databind-<span class="hljs-number">2.10</span><span class="hljs-number">.3</span>.jar:/Users/yuanzhipeng/.m2/repository/com/fasterxml/jackson/core/jackson-annotations/<span class="hljs-number">2.10</span><span class="hljs-number">.3</span>/jackson-annotations-<span class="hljs-number">2.10</span><span class="hljs-number">.3</span>.jar:/Users/yuanzhipeng/.m2/repository/com/fasterxml/jackson/core/jackson-core/<span class="hljs-number">2.10</span><span class="hljs-number">.3</span>/jackson-core-<span class="hljs-number">2.10</span><span class="hljs-number">.3</span>.jar:/Users/yuanzhipeng/.m2/repository/com/fasterxml/jackson/datatype/jackson-datatype-jdk8/<span class="hljs-number">2.10</span><span class="hljs-number">.3</span>/jackson-datatype-jdk8-<span class="hljs-number">2.10</span><span class="hljs-number">.3</span>.jar:/Users/yuanzhipeng/.m2/repository/com/fasterxml/jackson/datatype/jackson-datatype-jsr310/<span class="hljs-number">2.10</span><span class="hljs-number">.3</span>/jackson-datatype-jsr310-<span class="hljs-number">2.10</span><span class="hljs-number">.3</span>.jar:/Users/yuanzhipeng/.m2/repository/com/fasterxml/jackson/<span class="hljs-keyword">module</span>/jackson-<span class="hljs-keyword">module</span>-parameter-names/<span class="hljs-number">2.10</span><span class="hljs-number">.3</span>/jackson-<span class="hljs-keyword">module</span>-parameter-names-<span class="hljs-number">2.10</span><span class="hljs-number">.3</span>.jar:/Users/yuanzhipeng/.m2/repository/org/springframework/boot/spring-boot-starter-tomcat/<span class="hljs-number">2.2</span><span class="hljs-number">.6</span>.RELEASE/spring-boot-starter-tomcat-<span class="hljs-number">2.2</span><span class="hljs-number">.6</span>.RELEASE.jar:/Users/yuanzhipeng/.m2/repository/org/apache/tomcat/embed/tomcat-embed-core/<span class="hljs-number">9.0</span><span class="hljs-number">.33</span>/tomcat-embed-core-<span class="hljs-number">9.0</span><span class="hljs-number">.33</span>.jar:/Users/yuanzhipeng/.m2/repository/org/apache/tomcat/embed/tomcat-embed-el/<span class="hljs-number">9.0</span><span class="hljs-number">.33</span>/tomcat-embed-el-<span class="hljs-number">9.0</span><span class="hljs-number">.33</span>.jar:/Users/yuanzhipeng/.m2/repository/org/apache/tomcat/embed/tomcat-embed-websocket/<span class="hljs-number">9.0</span><span class="hljs-number">.33</span>/tomcat-embed-websocket-<span class="hljs-number">9.0</span><span class="hljs-number">.33</span>.jar:/Users/yuanzhipeng/.m2/repository/org/springframework/boot/spring-boot-starter-validation/<span class="hljs-number">2.2</span><span class="hljs-number">.6</span>.RELEASE/spring-boot-starter-validation-<span class="hljs-number">2.2</span><span class="hljs-number">.6</span>.RELEASE.jar:/Users/yuanzhipeng/.m2/repository/jakarta/validation/jakarta.validation-api/<span class="hljs-number">2.0</span><span class="hljs-number">.2</span>/jakarta.validation-api-<span class="hljs-number">2.0</span><span class="hljs-number">.2</span>.jar:/Users/yuanzhipeng/.m2/repository/org/hibernate/validator/hibernate-validator/<span class="hljs-number">6.0</span><span class="hljs-number">.18</span>.Final/hibernate-validator-<span class="hljs-number">6.0</span><span class="hljs-number">.18</span>.Final.jar:/Users/yuanzhipeng/.m2/repository/org/jboss/logging/jboss-logging/<span class="hljs-number">3.4</span><span class="hljs-number">.1</span>.Final/jboss-logging-<span class="hljs-number">3.4</span><span class="hljs-number">.1</span>.Final.jar:/Users/yuanzhipeng/.m2/repository/com/fasterxml/classmate/<span class="hljs-number">1.5</span><span class="hljs-number">.1</span>/classmate-<span class="hljs-number">1.5</span><span class="hljs-number">.1</span>.jar:/Users/yuanzhipeng/.m2/repository/org/springframework/spring-web/<span class="hljs-number">5.2</span><span class="hljs-number">.5</span>.RELEASE/spring-web-<span class="hljs-number">5.2</span><span class="hljs-number">.5</span>.RELEASE.jar:/Users/yuanzhipeng/.m2/repository/org/springframework/spring-beans/<span class="hljs-number">5.2</span><span class="hljs-number">.5</span>.RELEASE/spring-beans-<span class="hljs-number">5.2</span><span class="hljs-number">.5</span>.RELEASE.jar:/Users/yuanzhipeng/.m2/repository/org/springframework/spring-webmvc/<span class="hljs-number">5.2</span><span class="hljs-number">.5</span>.RELEASE/spring-webmvc-<span class="hljs-number">5.2</span><span class="hljs-number">.5</span>.RELEASE.jar:/Users/yuanzhipeng/.m2/repository/org/springframework/spring-aop/<span class="hljs-number">5.2</span><span class="hljs-number">.5</span>.RELEASE/spring-aop-<span class="hljs-number">5.2</span><span class="hljs-number">.5</span>.RELEASE.jar:/Users/yuanzhipeng/.m2/repository/org/springframework/spring-context/<span class="hljs-number">5.2</span><span class="hljs-number">.5</span>.RELEASE/spring-context-<span class="hljs-number">5.2</span><span class="hljs-number">.5</span>.RELEASE.jar:/Users/yuanzhipeng/.m2/repository/org/springframework/spring-expression/<span class="hljs-number">5.2</span><span class="hljs-number">.5</span>.RELEASE/spring-expression-<span class="hljs-number">5.2</span><span class="hljs-number">.5</span>.RELEASE.jar:/Users/yuanzhipeng/.m2/repository/org/slf4j/slf4j-api/<span class="hljs-number">1.7</span><span class="hljs-number">.30</span>/slf4j-api-<span class="hljs-number">1.7</span><span class="hljs-number">.30</span>.jar:/Users/yuanzhipeng/.m2/repository/org/springframework/spring-core/<span class="hljs-number">5.2</span><span class="hljs-number">.5</span>.RELEASE/spring-core-<span class="hljs-number">5.2</span><span class="hljs-number">.5</span>.RELEASE.jar:/Users/yuanzhipeng/.m2/repository/org/springframework/spring-jcl/<span class="hljs-number">5.2</span><span class="hljs-number">.5</span>.RELEASE/spring-jcl-<span class="hljs-number">5.2</span><span class="hljs-number">.5</span>.RELEASE.jar com.springboot.yzp.SpringbootYzpApplication<br>               __<br>              /\ \<br>  ____  __  __\ \ \____  __  _<br> /<span class="hljs-string">&#x27;,__\/\ \/\ \\ \ &#x27;</span>__`\/\ \/<span class="hljs-string">&#x27;\</span><br><span class="hljs-string">/\__, `\ \ \_\ \\ \ \L\ \/&gt;  &lt;/</span><br><span class="hljs-string">\/\____/\/`____ \\ \_,__//\_/\_\</span><br><span class="hljs-string"> \/___/  `/___/&gt; \\/___/ \//\/_/</span><br><span class="hljs-string">            /\___/</span><br><span class="hljs-string">            \/__/               </span><br><span class="hljs-string">2020-05-02 18:31:17.372  INFO 58694 --- [           main] c.s.yzp.SpringbootYzpApplication         : Starting SpringbootYzpApplication on yuanzhipengdeMacBook-Pro-2.local with PID 58694 (/Users/yuanzhipeng/idea/SpringBoot-yzp/springboot-yzp/target/classes started by yuanzhipeng in /Users/yuanzhipeng/idea/SpringBoot-yzp)</span><br><span class="hljs-string">2020-05-02 18:31:17.375  INFO 58694 --- [           main] c.s.yzp.SpringbootYzpApplication         : No active profile set, falling back to default profiles: default</span><br><span class="hljs-string">2020-05-02 18:31:18.169  INFO 58694 --- [           main] o.s.b.w.embedded.tomcat.TomcatWebServer  : Tomcat initialized with port(s): 8080 (http)</span><br><span class="hljs-string">2020-05-02 18:31:18.186  INFO 58694 --- [           main] o.apache.catalina.core.StandardService   : Starting service [Tomcat]</span><br><span class="hljs-string">2020-05-02 18:31:18.187  INFO 58694 --- [           main] org.apache.catalina.core.StandardEngine  : Starting Servlet engine: [Apache Tomcat/9.0.33]</span><br><span class="hljs-string">2020-05-02 18:31:18.256  INFO 58694 --- [           main] o.a.c.c.C.[Tomcat].[localhost].[/]       : Initializing Spring embedded WebApplicationContext</span><br><span class="hljs-string">2020-05-02 18:31:18.257  INFO 58694 --- [           main] o.s.web.context.ContextLoader            : Root WebApplicationContext: initialization completed in 842 ms</span><br><span class="hljs-string">2020-05-02 18:31:18.442  INFO 58694 --- [           main] o.s.s.concurrent.ThreadPoolTaskExecutor  : Initializing ExecutorService &#x27;</span>applicationTaskExecutor<span class="hljs-string">&#x27;</span><br><span class="hljs-string">2020-05-02 18:31:18.655  INFO 58694 --- [           main] o.s.b.w.embedded.tomcat.TomcatWebServer  : Tomcat started on port(s): 8080 (http) with context path &#x27;</span><span class="hljs-string">&#x27;</span><br><span class="hljs-string">2020-05-02 18:31:18.659  INFO 58694 --- [           main] c.s.yzp.SpringbootYzpApplication         : Started SpringbootYzpApplication in 1.584 seconds (JVM running for 2.083)</span><br></code></pre></td></tr></table></figure><p>banner也可以关闭，在mian方法中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.springboot.yzp;<br><br><span class="hljs-keyword">import</span> org.springframework.boot.Banner;<br><span class="hljs-keyword">import</span> org.springframework.boot.SpringApplication;<br><span class="hljs-keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;<br><br><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SpringbootYzpApplication</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        SpringApplication app = <span class="hljs-keyword">new</span> SpringApplication(SpringbootYzpApplication.class);<br>        app.setBannerMode(Banner.Mode.OFF);<br>        app.run(args);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="全局配置文件"><a href="#全局配置文件" class="headerlink" title="全局配置文件"></a>全局配置文件</h2><p>在src/main/sources目录下，SpringBoot提供了一个名为application.properties的全局配置文件，可对一些默认配置进行修改</p><p><code>附件：</code><a href="https://docs.spring.io/spring-boot/docs/current/reference/html/common-application-properties.html">application.properties中可配置所有官方属性</a></p><h2 id="使用xml配置"><a href="#使用xml配置" class="headerlink" title="使用xml配置"></a>使用xml配置</h2><p>虽然Spring Boot并不推荐我们继续使用xml配置，但如果出现不得不使用xml配置的情况，Spring Boot允许我们在入口类里通过注解<code>@ImportResource(&#123;&quot;classpath:some-application.xml&quot;&#125;)</code>来引入xml配置文件。</p><h2 id="Profile配置"><a href="#Profile配置" class="headerlink" title="Profile配置"></a>Profile配置</h2><p>Profile用来针对不同的环境下使用不同的配置文件，多环境配置文件必须以<code>application-&#123;profile&#125;.properties</code>的格式命，其中<code>&#123;profile&#125;</code>为环境标识。比如定义两个配置文件：</p><ul><li>application-dev.properties：测试环境：</li></ul><p><code>server.port=8081</code></p><ul><li>application-prod.properties：生产环境：</li></ul><p>`server.port=80812</p><p>至于哪个具体的配置文件会被加载，需要在application.properties文件中通过<code>spring.profiles.active</code>属性来设置，其值对应<code>&#123;profile&#125;</code>值。</p><p>如：<code>spring.profiles.active=dev</code>就会加载application-dev.properties配置文件内容。可以在运行jar文件的时候使用命令<code>java -jar xxx.jar --spring.profiles.active=&#123;profile&#125;</code>切换不同的环境配置。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2020/12/02/2020-05-02-SpringBoot%E5%AD%A6%E4%B9%A0(%E4%B8%89)%E3%80%81%E5%BC%95%E5%85%A5thymeleaf%E6%A8%A1%E7%89%88%E5%BC%95%E6%93%8E/"/>
    <url>/2020/12/02/2020-05-02-SpringBoot%E5%AD%A6%E4%B9%A0(%E4%B8%89)%E3%80%81%E5%BC%95%E5%85%A5thymeleaf%E6%A8%A1%E7%89%88%E5%BC%95%E6%93%8E/</url>
    
    <content type="html"><![CDATA[<h1 id="SpringBoot-引入thymeleaf"><a href="#SpringBoot-引入thymeleaf" class="headerlink" title="SpringBoot 引入thymeleaf"></a>SpringBoot 引入thymeleaf</h1><p>在SpringBoot项目中使用Thymeleaf只需在pom.xml中加入相关依赖即可</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;dependency&gt;<br>    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;<br>    &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;<br>&lt;/dependency&gt;<br></code></pre></td></tr></table></figure><p>在Spring Boot中，默认的html页面地址为src/main/resources/templates，默认的静态资源地址为src/main/resources/static。</p><h2 id="Thymeleaf默认配置"><a href="#Thymeleaf默认配置" class="headerlink" title="Thymeleaf默认配置"></a>Thymeleaf默认配置</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java">#开启模板缓存（默认值：true）<br>spring.thymeleaf.cache=<span class="hljs-keyword">true</span> <br>#Check that the template exists before rendering it.<br>spring.thymeleaf.check-template=<span class="hljs-keyword">true</span> <br>#检查模板位置是否正确（默认值:true）<br>spring.thymeleaf.check-template-location=<span class="hljs-keyword">true</span><br>#Content-Type的值（默认值：text/html）<br>spring.thymeleaf.content-type=text/html<br>#开启MVC Thymeleaf视图解析（默认值：true）<br>spring.thymeleaf.enabled=<span class="hljs-keyword">true</span><br>#模板编码<br>spring.thymeleaf.encoding=UTF-<span class="hljs-number">8</span><br>#要被排除在解析之外的视图名称列表，用逗号分隔<br>spring.thymeleaf.excluded-view-names=<br>#要运用于模板之上的模板模式。另见StandardTemplate-ModeHandlers(默认值：HTML5)<br>spring.thymeleaf.mode=HTML5<br>#在构建URL时添加到视图名称前的前缀（默认值：classpath:/templates/）<br>spring.thymeleaf.prefix=classpath:/templates/<br>#在构建URL时添加到视图名称后的后缀（默认值：.html）<br>spring.thymeleaf.suffix=.html<br>#Thymeleaf模板解析器在解析器链中的顺序。默认情况下，它排第一位。顺序从1开始，只有在定义了额外的TemplateResolver Bean时才需要设置这个属性。<br>spring.thymeleaf.template-resolver-order=<br>#可解析的视图名称列表，用逗号分隔<br>spring.thymeleaf.view-names=<br></code></pre></td></tr></table></figure><p>一般开发中将<code>spring.thymeleaf.cache</code>设置为false，其他保持默认值即可。</p><h2 id="编写简单的示例"><a href="#编写简单的示例" class="headerlink" title="编写简单的示例"></a>编写简单的示例</h2><p>编写entity：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Account</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> String account;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> String password;<br>    <span class="hljs-keyword">private</span> String accountType;<br>    <span class="hljs-keyword">private</span> String tel;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Account</span><span class="hljs-params">(String account, String name, String password, String accountType, String tel)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>();<br>        <span class="hljs-keyword">this</span>.account = account;<br>        <span class="hljs-keyword">this</span>.name = name;<br>        <span class="hljs-keyword">this</span>.password = password;<br>        <span class="hljs-keyword">this</span>.accountType = accountType;<br>        <span class="hljs-keyword">this</span>.tel = tel;<br>    &#125;<br><span class="hljs-comment">//忽略setter和getter方法</span><br>&#125;<br></code></pre></td></tr></table></figure><p>编写controller</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Controller</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IndexController</span> </span>&#123;<br><br>    <span class="hljs-meta">@RequestMapping(&quot;/account&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">index</span><span class="hljs-params">(Model m)</span> </span>&#123;<br>        List&lt;Account&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;Account&gt;();<br>        list.add(<span class="hljs-keyword">new</span> Account(<span class="hljs-string">&quot;KangKang&quot;</span>, <span class="hljs-string">&quot;康康&quot;</span>, <span class="hljs-string">&quot;e10adc3949ba59abbe56e&quot;</span>, <span class="hljs-string">&quot;超级管理员&quot;</span>, <span class="hljs-string">&quot;17777777777&quot;</span>));<br>        list.add(<span class="hljs-keyword">new</span> Account(<span class="hljs-string">&quot;Mike&quot;</span>, <span class="hljs-string">&quot;麦克&quot;</span>, <span class="hljs-string">&quot;e10adc3949ba59abbe56e&quot;</span>, <span class="hljs-string">&quot;管理员&quot;</span>, <span class="hljs-string">&quot;13444444444&quot;</span>));<br>        list.add(<span class="hljs-keyword">new</span> Account(<span class="hljs-string">&quot;Jane&quot;</span>,<span class="hljs-string">&quot;简&quot;</span>,<span class="hljs-string">&quot;e10adc3949ba59abbe56e&quot;</span>,<span class="hljs-string">&quot;运维人员&quot;</span>,<span class="hljs-string">&quot;18666666666&quot;</span>));<br>        list.add(<span class="hljs-keyword">new</span> Account(<span class="hljs-string">&quot;Maria&quot;</span>, <span class="hljs-string">&quot;玛利亚&quot;</span>, <span class="hljs-string">&quot;e10adc3949ba59abbe56e&quot;</span>, <span class="hljs-string">&quot;清算人员&quot;</span>, <span class="hljs-string">&quot;19999999999&quot;</span>));<br>        m.addAttribute(<span class="hljs-string">&quot;accountList&quot;</span>,list);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;account&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>编写account.html页面：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;!DOCTYPE html&gt;<br>&lt;html xmlns:th=<span class="hljs-string">&quot;http://www.thymeleaf.org&quot;</span>&gt;<br>&lt;head&gt;<br>    &lt;title&gt;account&lt;/title&gt;<br>    &lt;meta http-equiv=<span class="hljs-string">&quot;Content-Type&quot;</span> content=<span class="hljs-string">&quot;text/html; charset=UTF-8&quot;</span> /&gt;<br>    &lt;link rel=<span class="hljs-string">&quot;stylesheet&quot;</span> th:href=<span class="hljs-string">&quot;@&#123;/css/style.css&#125;&quot;</span> type=<span class="hljs-string">&quot;text/css&quot;</span>&gt;<br>&lt;/head&gt;<br>&lt;body&gt;<br>    &lt;table&gt;<br>        &lt;tr&gt;<br>            &lt;th&gt;no&lt;/th&gt;<br>            &lt;th&gt;account&lt;/th&gt;<br>            &lt;th&gt;name&lt;/th&gt;<br>            &lt;th&gt;password&lt;/th&gt;<br>            &lt;th&gt;accountType&lt;/th&gt;<br>            &lt;th&gt;tel&lt;/th&gt;<br>        &lt;/tr&gt;<br>        &lt;tr th:each=<span class="hljs-string">&quot;list,stat : $&#123;accountList&#125;&quot;</span>&gt;<br>            &lt;td th:text=&quot;$&#123;stat.count&#125;&quot;&gt;&lt;/td&gt;<br>            &lt;td th:text=&quot;$&#123;list.account&#125;&quot;&gt;&lt;/td&gt;<br>            &lt;td th:text=&quot;$&#123;list.name&#125;&quot;&gt;&lt;/td&gt;<br>            &lt;td th:text=&quot;$&#123;list.password&#125;&quot;&gt;&lt;/td&gt;<br>            &lt;td th:text=&quot;$&#123;list.accountType&#125;&quot;&gt;&lt;/td&gt;<br>            &lt;td th:text=&quot;$&#123;list.tel&#125;&quot;&gt;&lt;/td&gt;<br>        &lt;/tr&gt;<br>    &lt;/table&gt;<br>&lt;/body&gt;<br>&lt;/html&gt;<br></code></pre></td></tr></table></figure><p>最后启动项目访问：http:// localhost.8081/web/account</p><ul><li>附： <a href="https://github.com/yuanzhipeng/SpringBoot-yzp">source</a></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2020/12/02/2020-04-19-Dubbo/"/>
    <url>/2020/12/02/2020-04-19-Dubbo/</url>
    
    <content type="html"><![CDATA[<h1 id="Dubbo基础"><a href="#Dubbo基础" class="headerlink" title="Dubbo基础"></a>Dubbo基础</h1><h3 id="Dubbo是什么"><a href="#Dubbo是什么" class="headerlink" title="Dubbo是什么"></a>Dubbo是什么</h3><p>Dubbo是一个分布式、高性能、透明化的RPC服务框架，提供服务自动注册、自动发现等高效服务治理方案，可以和Spring框架无缝集成。</p><h3 id="Dubbo的主要应用场景"><a href="#Dubbo的主要应用场景" class="headerlink" title="Dubbo的主要应用场景"></a>Dubbo的主要应用场景</h3><ul><li>透明化的远程方法调用，就像调用本地方法一样调用远程方法，只要简单配置，没有任何API侵入</li><li>软负载均衡及容错机制，可在内网代替F5等硬件负载均衡器，降低成本，减少单点。</li><li>服务自动注册与发现，不需要写死服务提供方地址，注册中心基于接口名查询服务提供的IP地址，并且能够平滑添加删除服务提供者。</li></ul><h3 id="Dubbo的核心功能"><a href="#Dubbo的核心功能" class="headerlink" title="Dubbo的核心功能"></a>Dubbo的核心功能</h3><ul><li><strong>Remoting：</strong>网络通信框架，提供对多种NIO框架抽象封装，包括“同步转异步”和“请求-响应”模式的信息交换方式。</li><li><strong>Cluster：服务框架</strong> 提供基于接口方法的透明远程过程调用，包括多协议支持，以及软负载均衡，失败容错，地址路由，动态配置等集群支持。</li><li><strong>Registry：服务注册</strong>基于注册中心服务目录，使服务消费方能动态查找服务提供方，使地址透明，使服务提供方可以平滑增加或减少机器。</li></ul><h3 id="Dubbo支持那些协议，美中协议的应用场景，优缺点；"><a href="#Dubbo支持那些协议，美中协议的应用场景，优缺点；" class="headerlink" title="Dubbo支持那些协议，美中协议的应用场景，优缺点；"></a>Dubbo支持那些协议，美中协议的应用场景，优缺点；</h3><ul><li><strong>Dubbo：</strong>单一长连接和NIO异步通讯，适合大并发小数据量的服务调用，以及消费者远大于提供者。传输协议TCP，异步，Hessian序列化；</li><li><strong>rmi：</strong>采用JDK标准的rmi协议实现，传输参数和返回参数对象需要实现Serializable接口，使用java标准序列化机制吗使用阻塞式短连接，传输数据包大小混合，TCP协议传输，同步传输，使用常规的远程服务调用和rmi互操作。在依赖低版本的Common-Collections包，java序列化存在安全漏洞；</li><li><strong>webservice：</strong>基于WebService的远程调用协议，继承CXF实现，提供和原生WebService的互操作。多个短连接，基于HTTP传输，同步传输，适用系用集成和跨语言调用；</li><li>**http:**基于Http表单提交的远程调用协议，使用SPring的HttpInvoke实现。多个短连接，传输协议HTTP，传入参数大小混合，提供者个数多于消费者，需要给应用程序和浏览器JS调用；</li><li><strong>hessian：</strong>继承Hessian服务，基于HTTP通讯，采用Servlet暴露服务，Dubbo内嵌Jetty作为服务器时默认实现，提供于Hession服务互操作。多个短连接，同步HTTP传输，Hessian序列化，传入参数较大，提供者大雨消费者，提供者压力较大，可传文件。</li><li><strong>memcache：</strong>基于memcached实现的RPC协议；</li><li><strong>redis：</strong>基于redis实现的RPC协议；</li></ul><h3 id="Dubbo服务注册与发现流程"><a href="#Dubbo服务注册与发现流程" class="headerlink" title="Dubbo服务注册与发现流程"></a>Dubbo服务注册与发现流程</h3><h4 id="流程说明："><a href="#流程说明：" class="headerlink" title="流程说明："></a>流程说明：</h4><ul><li>Provider(提供者)绑定指定端口并启动服务</li><li>提供者连接注册中心，并发本机IP、端口、应用信息和提供服务信息发送至注册中心存储</li><li>Consumer(消费者)，连接注册中心，并发送应用信息、所求服务信息至注册中心</li><li>注册中心根据消费者所求服务信息匹配对应的提供者列表发送至Consumer应用缓存</li><li>Consumer在发起远程调用时基于缓存的消费者列表择其一发起调用</li><li>Provider状态变更会实时通知注册中心，在注册中心实时推送至Consumer。</li></ul><h3 id="Dubbo框架设计一共划分了10个层："><a href="#Dubbo框架设计一共划分了10个层：" class="headerlink" title="Dubbo框架设计一共划分了10个层："></a>Dubbo框架设计一共划分了10个层：</h3><ul><li>**服务接口层(Service):**该层使与实际业务逻辑相关的，根据服务提供方和服务消费方的业务设计对应的接口和实现。</li><li><strong>配置层(Config)：</strong>对外配置接口，以ServiceConfig和ReferenceConfig为中心。</li><li><strong>服务代理层(Proxy)：</strong>服务接口透明代理，生成服务的客户端Stub和服务器端Skeleton。</li><li><strong>服务注册层（Registry）：</strong>封装服务地址的注册与发现，以服务URL为中心。</li><li><strong>集群层（Cluster）：</strong>封装多个提供者的路由及负载均衡，并桥接注册中心，以Invoker为中心。</li><li><strong>监控层（Monitor）：</strong>RPC调用次数和调用时间监控。</li><li>远程调用层（Protocol）：**封装RPC调用，以Invocation和Result为中心，拓展接口为Protocol、Invoker和Exporter。</li><li><strong>信息交换层（Exchange）：</strong>封装请求响应模式，同步转异步，以Request和Response为中心。</li><li><strong>网络传输层（Transport）：</strong>抽象mina和netty为统一接口，以Message为中心。</li></ul><h3 id="Dubbo的注册中心集群挂掉，发布者和订阅者之间还能通信么？"><a href="#Dubbo的注册中心集群挂掉，发布者和订阅者之间还能通信么？" class="headerlink" title="Dubbo的注册中心集群挂掉，发布者和订阅者之间还能通信么？"></a>Dubbo的注册中心集群挂掉，发布者和订阅者之间还能通信么？</h3><p>可以的，启动dubbo时，消费者会从zookeeper拉取注册的生产者的地址接口等数据，缓存在本地，每次调用时，按照本地存储的地址进行调用。</p><h3 id="Dubbo集群提供了那些负载均衡策略"><a href="#Dubbo集群提供了那些负载均衡策略" class="headerlink" title="Dubbo集群提供了那些负载均衡策略"></a>Dubbo集群提供了那些负载均衡策略</h3><ul><li><strong>Random LoadBalance（缺省）：</strong>随机选取提供者策略，有利于动态调整提供者权重。截面碰撞率高，调用次数多，分布越均匀；</li><li><strong>RoundRobin LoanBalance：</strong>轮循选取提供者策略，平均分布，但是存在请求累积问题；</li><li><strong>LeastActive LoanBalance：</strong>最少活跃调用策略，解决慢提供者接收更少的请求；</li><li><strong>ConstantHash LoandBalance：</strong>一致性Hash策略，使相同参数请求总是发到同一提供者，一台机器宕机，可以基于虚拟节点，分摊至其他提供者，避免引起提供者的剧烈变动；</li></ul><h3 id="Dubbo的集群容错方案有哪些？"><a href="#Dubbo的集群容错方案有哪些？" class="headerlink" title="Dubbo的集群容错方案有哪些？"></a>Dubbo的集群容错方案有哪些？</h3><ul><li><strong>Failover Cluster：（缺省）</strong>失败自动切换，当出现失败，重试其他服务器。通常用于读操作，但充实会带来更长延时。</li><li><strong>Failfast Cluster：</strong>快速失败，只发起一次调用，失败立即报错。通常用于非幂等性的写操作，比如新增记录。</li><li><strong>Failback Cluster：</strong>失败自动恢复，后台记录失败请求，定时重发。通常用于消息通知操作。</li><li><strong>Forking Cluster：</strong>并行调用多个服务器，只要一个成功即返回。通常同于实时性要求较高的读操作，但需要浪费更多的服务资源。可通过forks=“2”来设置最大并行数。</li><li><strong>Broadcast Cluster：</strong>广播调用所有提供者，逐个调用，任意一台报错则报错。通常用于通知所有提供者更新缓存或日志等本地资源信息。</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2020/12/02/2020-04-19-Zookeeper%E5%9F%BA%E7%A1%80/"/>
    <url>/2020/12/02/2020-04-19-Zookeeper%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h1 id="Zookeeper基础"><a href="#Zookeeper基础" class="headerlink" title="Zookeeper基础"></a>Zookeeper基础</h1><h3 id="Zookeeper是什么"><a href="#Zookeeper是什么" class="headerlink" title="Zookeeper是什么"></a>Zookeeper是什么</h3><p>Zookeeper是一个分布式的，开放源码的分布式应用程序协调服务，是Goole的Chubby一个开源的实现，它是集群的管理者，监视者集群中各个节点的状态根据几诶单提交的反馈进行下一步合理操作。最终，将简单易用的接口个性能高效，功能稳定的系统提供给用户。</p><p>客户端的读请求可以被集群中的任意一台机器处理，如果读请求在节点上航注册了监听器，这个监听器也是有所连接的zookeeper机器来处理。对于写请求，这些请求会同事发送给其他zookeeper机器并且达成一致后，请求才会返回成功。因此，随着zookeeper中非常重要的一个特性，所有的更新都是全局有序的，每个更新都有一个唯一的时间戳，这个时间戳称为zxid（Zookeeper Transaction Id）。而读请求只会相对与更新有序，也就是读请求的返回结果中会带有这个zookeeper最新的zxid。</p><h3 id="Zookeeper提供了什么？"><a href="#Zookeeper提供了什么？" class="headerlink" title="Zookeeper提供了什么？"></a>Zookeeper提供了什么？</h3><ul><li>文件系统    </li><li>通知机制</li></ul><h3 id="Zookeeper文件系统"><a href="#Zookeeper文件系统" class="headerlink" title="Zookeeper文件系统"></a>Zookeeper文件系统</h3><p>Zookeeper提供一个多层级的节点命名空间(节点称为znode)。与文件系统不同的是，这些节点<strong>都可以设置关联的数据</strong>，而文件系统中只有文件节点可以存放数据而目录节点不行。Zookeeper为了保证高吞吐和低延迟，在内存中维护了梳妆的目录结构，这种特性使得Zookeeper不能存放大量数据，每个节点的存放数据上限为<strong>1M</strong>。</p><h3 id="四种类型的znode"><a href="#四种类型的znode" class="headerlink" title="四种类型的znode"></a>四种类型的znode</h3><p>1.<strong>PERSISTENT-持久化目录节点</strong></p><p>​    客户端与zookeeper断开连接后，该节点依旧存在</p><p>2.<strong>PERSISENT_SEQUENTIAL-持久化顺序编号目录节点</strong></p><pre><code> 客户端与zookeeper断开连接后，该节点依旧存在，只是Zookeeper给该节点名称进行顺序编号</code></pre><p>3.<strong>EPHEMERAL-临时目录节点</strong></p><p>​    客户端与zookeeper断开连接后，该节点被删除</p><p>4.<strong>EPHEMERAL_SEQUENTIAL-临时顺序编号目录节点</strong></p><p>​    客户端与zookeeper断开后，该节点被删除，只是Zookeeper给该节点名称进行顺序编号</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2020/12/02/2020-05-01-%E9%87%8D%E6%96%B0%E8%AE%A4%E8%AF%86hashCode()%E4%B8%8Eequals/"/>
    <url>/2020/12/02/2020-05-01-%E9%87%8D%E6%96%B0%E8%AE%A4%E8%AF%86hashCode()%E4%B8%8Eequals/</url>
    
    <content type="html"><![CDATA[<h3 id="面试时，面试官可能会问你：”你重写过hashCode和equals么？为什么要重写equals时必须重写hashCode方法？“"><a href="#面试时，面试官可能会问你：”你重写过hashCode和equals么？为什么要重写equals时必须重写hashCode方法？“" class="headerlink" title="面试时，面试官可能会问你：”你重写过hashCode和equals么？为什么要重写equals时必须重写hashCode方法？“"></a>面试时，面试官可能会问你：”你重写过hashCode和equals么？为什么要重写equals时必须重写hashCode方法？“</h3><h4 id="hashCode-介绍"><a href="#hashCode-介绍" class="headerlink" title="hashCode()介绍"></a>hashCode()介绍</h4><p>hashCode()的作用是获取哈希码，也称为散列码；它实际上是返回一个int整数。这个哈希码的作用是确定该对象在哈希表中的索引位置。hashCode()定义在JDK的Object.java中，这就意味着Java中的任何类都包含有hashCode()函数。</p><p>散列表存储的是键值对(key-value)，它的特点是：能根据“键”快速的检索出对应的“值”。这其中就利用到了散列码！</p><h4 id="为什么要有hashCode"><a href="#为什么要有hashCode" class="headerlink" title="为什么要有hashCode"></a>为什么要有hashCode</h4><h5 id="我们以“HashSet时，如何检查重复“为例子来说明为什么要有hashCode："><a href="#我们以“HashSet时，如何检查重复“为例子来说明为什么要有hashCode：" class="headerlink" title="我们以“HashSet时，如何检查重复“为例子来说明为什么要有hashCode："></a>我们以“HashSet时，如何检查重复“为例子来说明为什么要有hashCode：</h5><p>当你把对象加入HashSet时，HashSet会先计算对象的hashcode值来判断对象加入的位置，同时也会与其他已经加入的对象的hashcode值作比较，如果没有相符的hashcode，HashSet会假设对象没有重复出现。但是如果发现有相同hashcode值的对象，这时会调用equals()方法来检查hashcode相等的对象是否真的相同。如果两者相同，HashSet就不会让其加入操作成功。如果不同的话，就会重新散列到其他位置。这样我们就大大减少了equals的次数，相应就大大提高了执行速度。</p><h3 id="hashCode-与equals-的相关规定"><a href="#hashCode-与equals-的相关规定" class="headerlink" title="hashCode()与equals()的相关规定"></a>hashCode()与equals()的相关规定</h3><p>1.如果两个对象相等，则hashcode一定也是相同的</p><p>2.两个对象相等，对两个对象分别调用equals方法都返回true</p><p>3.两个对象有相同的hashcode值，他们也不一定是相等的</p><p>4.equals方法被覆盖过，则hashcode方法也必须被覆盖</p><p>5.hashcode()的默认行为是对堆上的对象产生独特值。如果没有重写hashcode（），则该class的两个对象无论如何都不会相等（即使这两个对象指向相同的数据）。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2020/12/02/2020-04-17-MySQL%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    <url>/2020/12/02/2020-04-17-MySQL%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
    
    <content type="html"><![CDATA[<h2 id="性能基石-MySQL"><a href="#性能基石-MySQL" class="headerlink" title="性能基石 MySQL"></a>性能基石 MySQL</h2><h3 id="什么是数据库索引"><a href="#什么是数据库索引" class="headerlink" title="什么是数据库索引"></a>什么是数据库索引</h3><p>在关系 数据库中，索引是一种单独的、物理的对数据库表中一列或多列 的值进行排序的一种存储结构，它是某个表中一列或若干列值的集合和相应的志向表中物理标识这些 数值的数据页的逻辑指针清单。索引的作用相当于图书的目录，可以根据目录中的野马快速找到所需的内容。</p><p>索引提供只想存储在表的制定劣种的数据值指针，然后根据你制定的排序顺序对这些指针排序。数据库使用索引以找到特定值，然后顺指针找到包含该值的行。这样可以使对应于表的SQL语句执行得更快，可快速访问数据库中的特定信息。</p><h3 id="MySQL索引类型和区别"><a href="#MySQL索引类型和区别" class="headerlink" title="MySQL索引类型和区别"></a>MySQL索引类型和区别</h3><p><strong>普通锁索引：</strong>即一个索引只包含单个列，一个表可以有多个单列索引</p><p><strong>唯一索引：</strong>索引列的值必须唯一，但允许有空值</p><p><strong>复合索引：</strong>即一个索引包含多列</p><p><strong>聚集索引：</strong>InnoDB，数据和索引放到一起</p><p><strong>非聚集索引：</strong>MyIsam，数据和索引文件分开存放</p><h3 id="如何进行SQL优化？"><a href="#如何进行SQL优化？" class="headerlink" title="如何进行SQL优化？"></a>如何进行SQL优化？</h3><h4 id="环境方面"><a href="#环境方面" class="headerlink" title="环境方面"></a>环境方面</h4><p>1.尽可能的使用告诉磁盘和大内存</p><p>2.服务器使用Linux，并且进行操作系统级别的调优，比如网络参数、避免使用Swap交换区等等</p><h4 id="SQL相关"><a href="#SQL相关" class="headerlink" title="SQL相关"></a>SQL相关</h4><p>1.<strong>先找到慢查询，</strong>慢查询日志，顾名思义，就是查询慢的日志，是指MySQL记录又有执行超过long_query_time参数设定的时间阀值的SQL语句日志。该日志能为SQL的优化带来很好的帮助。默认情况下，慢查询日志是关闭的，要是用慢查询日志功能，首先要开启慢查询日志功能。</p><ul><li><strong>Slow_query_log</strong>   启动停止记录慢查询日志</li><li><strong>Slow_query_log_file</strong>   指定慢查询日志得存储路径及文件(默认和数据文件放一起)</li><li><strong>long_query_time</strong>   指定记录慢查询日志SQL执行时间的阀值(单位：秒，默认10秒)</li><li><strong>long_queries_not_usinng_indexes</strong>  是否记录未使用索引的SQL</li><li><strong>long_ooutput</strong>  日志存档的地方 【<code>TABLE</code>、<code>FILE</code>、<code>FILE,TABLE</code>】</li></ul><p>2.<strong>分析慢查询日志。</strong>慢查询的 日志记录非常多，要从里面寻找一条查询慢的日志并不是很容易的事情，一般来说东欧需要一些工具辅助才能快速定位到需要优化的SQL语句，比如<code>Mysqldumpslow</code></p><p>3.<strong>SQL本身优化，</strong>比如少用自查询 ，in查询改关联查询，不实用外键于级联等等</p><p>4.<strong>反范式设计，</strong>字段允许适当冗余，选择合适的字段存储长度等等</p><p>5.<strong>使用执行计划分析SQL语句，</strong>使用EXPLAIN关键字可以模拟优化器 执行 SQL查询语句，从而知道MySQL是如何处理你的SQL语句。分析你的查询语句或是表结构的性能瓶颈，至少可以知道：</p><ul><li><p>表的读取顺序</p></li><li><p>数据读取操作的操作类型</p></li><li><p>那些索引可以使用</p></li><li><p>那些索引被实际使用</p></li><li><p>表之间的饮用</p></li><li><p>每张表有多少行被优化器查询</p><p><strong>比如，</strong>执行计划中deype显示的是访问类型 ，是较为重要的一个指标，结果值从最好到最坏依次是：</p><p>​    **system &gt; const &gt; eq_ref &gt; ref &gt;fulltext &gt; ref_or_null &gt; index_merge &gt; unique_subquery &gt; index_subquery &gt; range &gt; index &gt; ALL **</p><p>一般来说，得保证查询至少达到<strong>range</strong>级别，要求能达到<strong>ref</strong>。</p></li></ul><h3 id="优化10-大策略"><a href="#优化10-大策略" class="headerlink" title="优化10 大策略"></a>优化10 大策略</h3><p><strong>1.尽量全值匹配</strong></p><p>​    当简历了索引列侯，能在wherel条件中使用索引的尽量使用。</p><p><strong>2.最佳左前缀法则</strong></p><p>​    如果索引了多列，要最受最左前缀法则。指的是查询从索引的最左前列开始并且不跳过索引中的列。</p><p><strong>3.不再索引列上做任何操作</strong></p><p>​    不再索引列上做任何操作(计算、函数、(自动or手动)类型转换)，会 导致索引失效而转向全表扫描。</p><p><strong>4.范围条件放最后</strong></p><p>​    中间有范围查询会导致后面的索引列全部失效</p><p><strong>5.覆盖索引尽量用</strong></p><p>​    尽量使用覆盖索引(指一个查询语句的执行只用从索引中 就能够取得，不必从数据表中读取)，减少<code>select * </code>;</p><p><strong>6.不等于要慎用</strong></p><p>mysql在使用不等于(<code>!=</code> 或者<code>&lt; &gt;</code>)的时候无法使用索引会导致全表扫描，如果一定需要使用不等于，请使用覆盖索引</p><p><strong>7.Null/Not有影响</strong></p><p>​    注意null/not null 对索引的可能影响；</p><p>​    1.自定义为NOT NULL  在字段为not null的情况下，使用is null或 is not null会导致索引失效</p><p>​    解决方式：覆盖索引</p><p>​    2.自定义为NULL或者不定义</p><p>​    Is not null 的情况会导致索引失效        解决方式：覆盖索引</p><p><strong>8.Like查询要当心</strong></p><p>​    like已 通配符开头(‘%abc…’)mysql索引失效会变成全表扫描的操作      解决方式：覆盖索引</p><p><strong>9.自负类型加引号</strong></p><p>​    字符串不加单引号索引失效 </p><p><strong>10.OR改UNION效率高</strong></p><p>​    如果 一定要用OR，那么使用覆盖索引；</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2020/12/02/hello-world/"/>
    <url>/2020/12/02/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>ConcurrentHashMap</title>
    <link href="/2020/04/16/2020-04-15-ConcurrentHashMap/"/>
    <url>/2020/04/16/2020-04-15-ConcurrentHashMap/</url>
    
    <content type="html"><![CDATA[<h1 id="“ConcurrentHashMap”"><a href="#“ConcurrentHashMap”" class="headerlink" title="“ConcurrentHashMap”"></a>“<strong>ConcurrentHashMap</strong>”</h1><p>**<code>ConcurrentHashMap</code>**是线程安全的Map，在1.7和1.8中实现有所不同。</p><ul><li><p>在JDK1.7中采用分段锁的机制，实现并发的更新操作，底层采用数组+链表的存储结构，包含两个核心静态内部类<code>Segment</code>和<code>HashEntry</code>。</p><p>1.<code>Segment</code>继承<code>ReentrantLock</code>(重入锁)用来充当锁的角色，每个<code>Segment</code>对象守护每个散列映射表的若干个木桶；</p><p>2.<code>HashEntry</code>用来封装映射表的键-值对</p><p>3.每个桶石油若干个<code>HashEntry</code>对象链接起来的链表</p></li><li><p>在JDK1.8中，采用** Node + CAS + Synchronized来保证并发安全。取消类<code>Segment</code>，直接用table数组存储键值对；当<code>HashEntry</code>对象组成的链表长度超过<strong>TREEIFY_THRESHOLD</strong>时，链表转换为红黑树，提升性能。底层变更为数组 + 链表 + 红黑树</p><p>在1.8里</p><p>1.<strong>重要的常量： <code>private transient volatile int sizeCtl;</code></strong></p><p>​    当为负数时，-1表示正在初始化，-N表示N-1个线程正在进行扩容</p><p>​    当为0时，表示table还没有初始化</p><p>​    当为其他正数时，表示初始化或下一次进行扩容的大小</p><p>2.<strong>数据结构：</strong></p><p>​    <strong>Node</strong>是存储结构的基本单元，实现了Map中的<code>Entry</code>接口，用于存储数据</p><p>​    <strong>TreeNode</strong>继承<code>Node</code>，但是数据结构转换成了二叉树结构，是红黑树的存储结构，用于红黑树中存储数据</p><p>​    <strong>TreeBin</strong>是封装<code>TreeNode</code>的容器，提供转换红黑树的一些条件和锁的控制</p><p>3.<strong>存储对象是(<code>put()</code>方法)：</strong></p><p>​    1.如果没有初始化，就调用<code>initTable()</code>方法来进行初始化；</p><p>​    2.如果没有 hash 冲突就直接 CAS 无锁插入;</p><p>​    3.如果需要扩容，就先进行扩容;</p><p>​    4.如果存在hash冲突，就加锁来保证线程安全，两种情况：一种是链表形式就直接遍历到尾端插入，一种是红黑树就按照红黑树结构插入；</p><p>​    5.如果该链表的数量大于阀值 8，就要先转换成红黑树的结构；</p><p>​    6.如果添加成功就调用 <code>addCount()</code> 方法统计 size，并且检查是否需要扩容。</p></li><li><p>扩容方法<code>transfer()</code>默认容量为16，扩容时，容量变为原来的两倍；<code>helpTransfer()</code>调用多个工作线程一起帮助进行扩容，这样的效率就会更高</p></li><li><p><strong>获取对象时(<code>get()</code>方法)：</strong></p><p>1.计算hash值，定位到该table索引位置，如果是首节点符合就返回；</p><p>2.如果与到扩容时，会调用标记正在扩容节点<code>ForwardingNode.find()</code>方法，查找该节点匹配就返回；</p><p>3.以上都不符合的话，就遍历节点，匹配就返回，否则最后就返回null；</p></li></ul><h3 id="为什么hashmap-1-8-不直接使用红黑树而还要保留链表"><a href="#为什么hashmap-1-8-不直接使用红黑树而还要保留链表" class="headerlink" title="为什么hashmap 1.8 不直接使用红黑树而还要保留链表"></a>为什么hashmap 1.8 不直接使用红黑树而还要保留链表</h3><p>因为插入时红黑树需要进行左旋，右旋操作，而单链表不需要，在数量较少时，红黑树并没有表现出比链表更好的查询效率，而且在占用空间上，红黑树的节点比链表的节点更大，时链表的两倍；</p><h3 id="为什么大于8-个的时候才转换红黑树"><a href="#为什么大于8-个的时候才转换红黑树" class="headerlink" title="为什么大于8 个的时候才转换红黑树"></a>为什么大于8 个的时候才转换红黑树</h3><p><strong>按照 JDK 源码里解释是这样的:</strong></p><p><code>TreeNodes</code> 占用空间是普通 <code>Nodes</code> 的两倍，所以只有当 bin 包含足够多的节点时才会转成<code>TreeNode</code>s，而是否足够多就是由<code> TREEIFY_THRESHOLD</code> 的值决定的。当 bin 中节点数变少时， 又会转成普通的 bin。<code>TREEIFY_THRESHOLD</code> 的值是个空间和时间的权衡。</p><p>当 hashCode 离散性很好的时候，树型 bin 用到的概率非常小，因为数据均匀分布在每个 bin 中，几乎不会有 bin 中链表长度会达到阈值。</p><p>但是在随机 hashCode 下，离散性可能会变差，然而 JDK 又不能阻止用户实现这种不好的 hash 算法，因此就可能导致不均匀的数据分布。</p><p>不过理想情况下随机 hashCode 算法下所有 bin 中节点的分布频率会遵循泊松分布，</p><p>一个 bin 中链表长度达到 8 个元素的概率为 0.00000006，几乎是不可能事件。所以，之所 以选择 8，不是拍拍屁股决定的，而是根据概率统计决定的。</p><p><strong>当然网上也有这样的说法:</strong></p><p>红黑树的平均查找长度是 log(n)，如果长度为 8，平均查找长度为 log(8)=3，链表的平均查 找长度为 n/2，当长度为 8 时，平均查找长度为 8/2=4，这才有转换成树的必要;链表长度 如果是小于等于 6，6/2=3，而 log(6)=2.6，虽然速度也很快的，但是转化为树结构和生成树 的时间并不会太短。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>线程池</title>
    <link href="/2020/04/16/2020-04-15-%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    <url>/2020/04/16/2020-04-15-%E7%BA%BF%E7%A8%8B%E6%B1%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="“线程池”"><a href="#“线程池”" class="headerlink" title="“线程池”"></a>“线程池”</h1><hr><h2 id="ThreadPoolExecutor线程池参数详解"><a href="#ThreadPoolExecutor线程池参数详解" class="headerlink" title="ThreadPoolExecutor线程池参数详解"></a><code>ThreadPoolExecutor</code>线程池参数详解</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ThreadPoolExecutor</span><span class="hljs-params">(<span class="hljs-keyword">int</span> corePoolSize, <span class="hljs-keyword">int</span> maximumPoolSize, <span class="hljs-keyword">long</span> keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue,  ThreadFactory threadFactory, RejectedExecutionHandler handler)</span></span><br></code></pre></td></tr></table></figure><ul><li><p><code>corePoolSize</code><strong>：核心线程数</strong></p><p>当提交一个任务时，线程池创建一个信线程执行任务，直到当前线程数等于<code>corePoolSize</code>;如果当前线程数为<code>corePoolSize</code>,继续提交任务被保存到阻塞队列中，等待被执行；如果执行了线程池<code>prestartAllCoreThreads()</code>方法，线程池会提前创建并启动所有核心线程。</p></li><li><p><code>maximumPoolSize</code><strong>：最大线程数</strong></p><p>如果当前阻塞队列满了，且继续提交任务，则创建新的线程执行任务，前提是当前线程数小于<code>maximumPoolSize</code>；</p></li><li><p><code>TimeUnit</code><strong>:<code>keepAliveTime</code>的时间单位</strong></p></li><li><p><code>workQueue</code><strong>:<code>workQueue</code>必须是<code>BlockingQueue</code>阻塞队列当线程池中的线程数超过它的<code>corePoolSize</code>的时候,线程会进入阻塞队列进行阻塞等待。通过<code>workQueue</code>，线程池实现了阻塞功能。</strong></p><p>用于保存等待执行任务的阻塞队列，一般来说，我们应该尽量使用有界队列，因为使用无界队列作为工作队列会对线程池带来如下影响：</p><p>​    1.当线程池中的线程数达到<code>corePoolSize</code>后，新任务将在无界队列中等待，因此线程池中的线程数不会超过<code>corePoolSize</code></p><p>​    2.由于1，使用无界队列时<code>maximumPoolSize</code>将是一个无效参数</p><p>​    3.由于1和2，使用无界队列时<code>keepAliveTime</code>将是一个无效参数</p><p>​    4.更重要的是，使用无界Queue可能会耗尽系统资源，有界队列则有助于防止资源耗尽，同时即使使用有界        队列也要控制队列的大小在一个合适的范围。</p><p>所以我们一般会使用，<code>ArrayBlockingQueue</code>、<code>LinkedBlockingQueue</code>、<code>SynchronousQueue</code>、<code>PriorityBlockingQueue</code></p></li><li><p><code>threadFactory</code><strong>:创建线程池的工厂</strong></p><p>通过自定义的线程池工厂可以给每个新建的线程设置一个具有识别度的线程名，当然还可以更加自由的对线程做更多的设置，比如设置所有的线程为守护线程。<code>Executors</code>静态工厂里默认的<code>threadFactory</code>，线程的明明规则是”pool-数字-thread-数字”。</p></li><li><p><code>RejectedExecutionHandler</code><strong>:线程池的饱和策略</strong></p><p>当阻塞队列满了，且没有空闲的工作线程，如果继续提交任务，必须采取一种策略处理该任务，线程池提供了4中策略：</p><p>1.<code>AbortPolicy</code> : 直接抛出异常，默认策略</p><p>2.<code>CallerRunsPolicy</code> : 用调用者所在的线程来执行任务</p><p>3.<code>DiscardOldestPolicy</code> ： 丢弃阻塞队列中靠最前的任务，并执行当前任务</p><p>4.<code>DiscardPolicy</code> ： 直接丢弃任务</p><p>当然也可以根据应用场景实现<code>RejectedExecutionHandler</code>接口，自定义饱和策略，如记录日志或持久化存储不能处理的任务</p></li></ul><h3 id="如何合理地配置线程池"><a href="#如何合理地配置线程池" class="headerlink" title="如何合理地配置线程池"></a>如何合理地配置线程池</h3><p>要想合理地配置线程池，就必须首先分析任务特性，可以从以下几个角度来分析：</p><ul><li><strong>任务的性质：</strong>CPU密集型任务、IO密集型任务和混合型任务</li><li><strong>任务的优先级：</strong>高、中和低</li><li><strong>任务的执行时间：</strong>是都以来其他系统资源，如数据库连接</li></ul><p>性质不同的任务可以用不同规模的线程池分开处理</p><p>CPU密集型任务应配置尽可能小的线程，如配置<strong>Ncpu+1</strong>个线程的线程池。由于IO密集型任务并不是一直在执行任务，则应配置尽可能多的线程，如*<em>2</em>Ncpu**</p><p>混合型的任务，如果可以拆分，将其拆分为一个cpu密集型任务和一个IO密集型任务，只要这两个任务执行的时间相差不是太大，那么分解后执行的吞吐量将高于串行的吞吐量。如果这两个任务执行时间相差太大，则没必要进行茶粉。可以通过<code>Runtime.getRuntime().availableProcessors()</code>方法获取当前设备的CPU个数。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>锁</title>
    <link href="/2020/04/15/2020-04-15-%E9%94%81/"/>
    <url>/2020/04/15/2020-04-15-%E9%94%81/</url>
    
    <content type="html"><![CDATA[<h1 id="“锁”"><a href="#“锁”" class="headerlink" title="“锁”"></a>“锁”</h1><h3 id="Synchronized原理？"><a href="#Synchronized原理？" class="headerlink" title="Synchronized原理？"></a>Synchronized原理？</h3><p>这是一道Java面试中几乎百分百会问到的问题，因为没有任何写过并发的开发者会没听或者没接触过<code>Synchroized</code></p><p><code>Synchroized</code>是由JVM实现的一种实现互斥同步的一种方式，如果你查看被<code>Synchronized</code>修饰过的程序块编译后的字节码，会发现被<code>Synchronized</code>修饰过的程序块，在编译前后被编译器生成了<code>moniternter</code>和<code>monitorexit</code>两个字节码指令。</p><p><strong><em>这两个指令是什么意思呢？</em></strong></p><p>​    在虚拟机执行到<code>moniternter</code>指令时，首先要尝试获取对象的锁；如果这个对象没有锁定，或者当前线程已经拥有这个对象的锁，把锁的计数器+1；当执行<code>monitorexit</code>指令时讲锁计数器-1；当计数器为0时，锁就释放了。</p><p>​    如果获取对象失败了，当前线程就要阻塞等待，直到对象锁被另一个线程释放为止。</p><p><code>Java</code>中<code>Synchronized</code>通过在对象头设置标记，达到获取锁和释放锁的目的。</p><h3 id="刚才提到获取对象的锁，这个“锁”到底是什么？如何确定对象的锁？"><a href="#刚才提到获取对象的锁，这个“锁”到底是什么？如何确定对象的锁？" class="headerlink" title="刚才提到获取对象的锁，这个“锁”到底是什么？如何确定对象的锁？"></a>刚才提到获取对象的锁，这个“锁”到底是什么？如何确定对象的锁？</h3><p>“锁”的本质其实是<code>moniternter</code>和<code>monitorexit</code>字节码指令的一个<code>Reference</code>类型的参数，即要锁定的对象和解锁的对象。我们知道，使用<code>Synchronized</code>可以修饰不同的对象，因此，对应的对象锁可以这么确定。</p><ol><li><p>如果<code>Synchronized</code>明确指定了锁对象，比如<code>Synchronized(变量名)</code>、<code>Synchronized(this)</code>等，说明加解锁对象为该对象。</p></li><li><p>如果没有明确指定：</p><ul><li><p>若<code>Synchronized</code>修饰的方法为非静态方法，表示此方法对应的类对象为锁对象。</p></li><li><p>若<code>Synchronized</code>修饰的方法为静态方法，则表示此方法对应的类对象为锁对象。</p><p><strong>注意！！</strong>   当一个对象被锁住时，对象里面所有用<code>Synchronized</code>修饰的方法都将产生阻塞，而对象非<code>Synchronized</code>修饰的方法可正常被调用，不受影响。</p></li></ul></li></ol><h3 id="什么是可重入性，为什么说Synchronized是可重入锁？"><a href="#什么是可重入性，为什么说Synchronized是可重入锁？" class="headerlink" title="什么是可重入性，为什么说Synchronized是可重入锁？"></a>什么是可重入性，为什么说<code>Synchronized</code>是可重入锁？</h3><p>可重入性是锁的一个基本要求，是为了解决自己锁死自己的情况。举例：一个类中的同步方法调用另一个同步方法，假如<code>Synchronized</code>不支持重入，进入method2方法时当前线成获得锁，method2方法里面执行method1时当前线程又要去尝试获取锁，这时如果不支持重入，他就要等待释放，把自己阻塞，导致锁死自己。对<code>Synchronized</code>来说，可重入性是显而易见的，刚才提到，在执行<code>monitorenter</code>指令时，如果这个对象没有锁定，或者当前线程已经拥有了这个对象的锁 <strong>（而不是以拥有了锁则不能继续获取）</strong>，就把锁的计数器+1，其实本质上就通过这种方式实现了可重入性。</p><h3 id="JVM对Java的原生锁做了哪些优化？"><a href="#JVM对Java的原生锁做了哪些优化？" class="headerlink" title="JVM对Java的原生锁做了哪些优化？"></a>JVM对Java的原生锁做了哪些优化？</h3><p>在Java6之前，Monitor的实现完全依赖底层操作系统的互斥锁来实现，也就是我们刚才在问题二中所阐述的获取/释放逻辑。</p><p>由于Java层面的线程与操作系统的原生线程有映射关系，如果要将一个线程进行阻塞或唤起都需要操作系统的协助，这就需要从用户态切换到内核态来执行，这种切换代价十分昂贵，很耗处理器时间，现在JDK中做了大量的优化。</p><p>一种优化是使用自旋锁，即在把线程进行阻塞操作之前先让线程自旋等待一段时间，可能在等待期间其他线程已经解锁，这时就无需再让线程执行阻塞操作，避免了用户态到内核态的切换。</p><p>现代JDK中还提供了三种不同的<code>Monitor</code>实现，也就是三种不同的锁：</p><ul><li><p>偏向锁（Biased Locking）</p></li><li><p>轻量级锁</p></li><li><p>重量级锁</p><p>这三种锁使得JDK得以优化<code>Synchronized</code>的运行，当JVM检测到不同的竞争状况时，会自动切换到适合的锁实现，这就是锁的升级、降级。</p></li><li><p>当没有竞争出现时，默认会使用偏向锁</p><p><code>JVM会利用CAS操作，在对象头上的Mark Word部分设置线程ID，以表示这个对象偏向于当前线程，所以并不涉及真正的互斥锁门因为很多应用场景中，大部分对象生命周期中最多会被一个线程锁定，使用偏斜锁可以降低无竞争开销。</code></p><hr><hr></li><li><p>如果有另一线程试图锁定某个被偏斜过的对象，JVM就撤销偏斜锁，切换到轻量级锁实现。</p></li><li><p>轻量级锁以来CAS操作Mark Word来试图获取锁，如果重试成功，就使用普通的轻量级锁；否则，进一步升级为重量级锁。</p></li></ul><h3 id="为什么说Synchronized是非公平锁？"><a href="#为什么说Synchronized是非公平锁？" class="headerlink" title="为什么说Synchronized是非公平锁？"></a>为什么说<code>Synchronized</code>是非公平锁？</h3><p>非公平主要表现在获取锁的行为上，并非是按照申请锁的时间前后给等待线程分配锁的，每当锁被释放后，任何一个线程都有机会竞争到锁，这样做的目的是为了提高执行性能，缺点是可能 会产生线程饥饿现象。</p><h3 id="什么是锁消除和锁粗化？"><a href="#什么是锁消除和锁粗化？" class="headerlink" title="什么是锁消除和锁粗化？"></a>什么是锁消除和锁粗化？</h3><ul><li><strong>锁消除</strong>：指虚拟机即时编译器在运行时，对一些代码上要求同步，但被检测到不可能存在共享数据竞争的锁进行消除。主要根据逃逸分析。</li><li><strong>锁粗化</strong>：原则上，同步块的作用范围要尽量小。但是如果一系列的连续操作都对一个对象反复加锁和解锁，甚至枷锁操作在循环体内，频繁地进行互斥同步操作也会导致不必要的性能损耗。 锁粗化就是增大锁的作用域。</li></ul><h3 id="为什么说Synchronized是一个悲观锁？乐观锁的实现原理又是什么？什么是CAS，它有什么特性？"><a href="#为什么说Synchronized是一个悲观锁？乐观锁的实现原理又是什么？什么是CAS，它有什么特性？" class="headerlink" title="为什么说Synchronized是一个悲观锁？乐观锁的实现原理又是什么？什么是CAS，它有什么特性？"></a>为什么说<code>Synchronized</code>是一个悲观锁？乐观锁的实现原理又是什么？什么是CAS，它有什么特性？</h3><p><code>Synchronized</code>显然是一个悲观锁，因为它的并发策略是悲观的：</p><p><code>不管是否会产生竞争，任何的数据操作都必须要加锁、用户态核心态转换、维护锁计数器和检查是否有被阻塞的线程需要被唤醒等操作。</code>随着硬件指令集的发展，我们可以使用基于冲突检测的乐观并发策略，先进行操作，如果没有其他线程征用数据，那操作成功了；</p><p>​    如果共享数据有征用，产生了冲突，那就再进行其他的补偿措施。这种乐观的并发策略的许多实现不需要线程挂起，所以被称为非阻塞同步。</p><p>​    乐观锁的核心算法是<code>CAS(Compareand Swap, 比较并交换)</code>，它设计到三个操作数:内存值、预期值、新值。当且仅当内存值相等时才讲内存值修改为新值。这样的处理逻辑是，首先检查某块内存的值是否跟你之前我读区时的一样，如不一样则表示此内存值已经被别的线程更改过，舍弃本次操作块，否则说明期间没有其他线程对此内存值的操作，可以把新值设置给此块内存。</p><p>​    <code>CAS</code>具有原子性，它的原子性有CPU硬件指令实现保证，即使用<code>JNI</code>调用<code>Native</code>方法调用用由**C++**编写的硬件级别指令，<code>JDK</code>中提供了<code>Unsafe</code>类执行这些操作。</p><h3 id="乐观锁一定就是好的吗？"><a href="#乐观锁一定就是好的吗？" class="headerlink" title="乐观锁一定就是好的吗？"></a>乐观锁一定就是好的吗？</h3><p>乐观锁避免了悲观锁独占对象的现象，同时也提高了并发性能，但它也有缺点：</p><ol><li>乐观锁只能保证一个共享变量的原子操作。如果多一个或几个变量，乐观锁将变得力不从心，但互斥锁能轻易解决，不管对象数量多少及对象颗粒度大小。</li><li>长时间自旋可能导致开销大。加入<code>CAS</code>长时间不成功而一直自旋，会给CPU带来很大的开销。</li><li>ABA问题。<code>CAS</code>核心思想是通过比对内存值与预期值是否一样而判断内存是否被改过，但这个判断逻辑不严谨，加入内存值原来是A，后来被一条线程改为B，最后又被改成了A，则CAS认为此内存值并没有发生改变，但实际上是有被其他线程改过的，这种情况对以来过程值的情景运算结果影响很大。解决的思路是引入版本号，每次变量更新都把版本号加一。</li></ol><h3 id="可重入锁ReentrantLock及其他显示锁相关问题"><a href="#可重入锁ReentrantLock及其他显示锁相关问题" class="headerlink" title="可重入锁ReentrantLock及其他显示锁相关问题"></a>可重入锁<code>ReentrantLock</code>及其他显示锁相关问题</h3><ul><li><h4 id="跟Synchronized相比可重入锁ReentrantLock其实现原理有什么不同？"><a href="#跟Synchronized相比可重入锁ReentrantLock其实现原理有什么不同？" class="headerlink" title="跟Synchronized相比可重入锁ReentrantLock其实现原理有什么不同？"></a><strong>跟<code>Synchronized</code>相比可重入锁<code>ReentrantLock</code>其实现原理有什么不同？</strong></h4><p>其实，锁的实现原理基本都是为了达到一个目的：<strong>让所有的线程都能看到某种标记。</strong></p><p><code>Synchronized</code>通过在对象头中设置标记实现了这一目的，是一种JVM原生的锁的实现方式，而<code>ReentrantLock</code>以及所有的给予<code>Lock</code>接口的实现类，都是通过用一个<code>Volitile</code>修饰的<code>int</code>型变量，并保证悲歌线程都能拥有对该<code>int</code>的可见性和 原子修改，其本质是基于所有的<code>AQS</code>框架。</p><h3 id="什么是AQS框架？"><a href="#什么是AQS框架？" class="headerlink" title="什么是AQS框架？"></a>什么是<code>AQS</code>框架？</h3><p><code>AQS(AbstractQueuedSynchronizer)</code>是一个用来构建锁和同步锁的框架，各种<code>Lock</code>包中的锁(常用的有    <code>ReentrantLock</code>、 <code>ReadWriteLock</code>) ， 以 及 其 他 如 <code>Semaphore</code>、 <code>CountDownLatch</code>， 甚 至是早期的 <code>FutureTask</code> 等，都是基于 <code>AQS</code> 来构建。</p><ul><li><code>AQS</code>在内部定义了一个<code>volatile int state</code>变量，表示同步状态：当线程调用<code>lock</code>方法时，如果<code>state=0</code>,说明没有哦任何线程占用共享资源的锁，可以获得锁并将<code>state=1</code>；如果<code>state=1</code>，则说明又线程目前正在使用共享变量，其他线程必须加入同步队列进行等待。</li><li><code>AQS</code>通过<code>Node</code>内部类构成的一个双向链表结构的不同队列，来完成线程获取锁的排队工作，当有线程获取锁失败后，就被调价到队列末尾。<ul><li><code>Node</code>类是对要访问同步代码的线程的封装，包含了线程本身及其状态叫<code>waitStatus</code>(有五种不同去值，分别表示是否被阻塞，是否等待唤醒，是都已经被取消等)，每个<code>Node</code>节点关联其<code>prev</code>和<code>next</code>节点，方便线程释放锁后快速唤醒下一个在等待的线程，是一个<code>FIFO</code>的过程。</li><li><code>Node</code>类有两个常量，<code>SHARED</code>和<code>EXCLUSIVE</code>，分别代表共享模式和独占模式。所谓共享模式是一个锁允许多条线同时操作（信号量<code>Semaphore</code>就是基于<code>AQS</code>的共享模式实现的），独占模式是同一个时间段只能有一个线程对共享资源进行操作，多余的请求线程需要排队等待(如<code>ReentranLock</code>)。</li></ul></li><li><code>AQS</code>通过内部类<code>ConditionObject</code>构建等待队列(可有多个)，当<code>Condition</code>调用<code>wait()</code>方法后，线程会加入等待队列中，而当<code>Condition</code>调用<code>signal()</code>方法后，线程将从等待队列转移到同步队列中进行锁竞争。</li><li><code>AQS</code>和<code>Condition</code>个字维护了不同的队列，在使用<code>Lock</code>和<code>Condition</code>的时候，其实就是两个队列的互相移动。</li></ul></li></ul><h3 id="Synchronized和ReentrantLock的异同"><a href="#Synchronized和ReentrantLock的异同" class="headerlink" title="Synchronized和ReentrantLock的异同"></a><code>Synchronized</code>和<code>ReentrantLock</code>的异同</h3><p><code>ReentrantLock</code>是Lock的实现类，是一个互斥的同步锁。</p><p>从功能监督，<code>ReentrantLock</code>比<code>Synchronized</code>的同步操作更精细(因为可以像普通对象一样使用)，甚至实现<code>Synchronized</code>没有的高级功能，如：</p><ol><li><strong>等待可中断 ：</strong>当持有锁的线程长期不释放锁的时候，正在等待的线程可以选择 放弃等待，对处理执行时间非常长的同步块很有用。</li><li><strong>带超市的获取锁尝试：</strong>在指定的时间范围内获取锁，如果时间到了 仍然无法获取则返回。</li><li><strong>可以判断是否有线程在排队等待获取锁</strong></li><li><strong>可以响应中断请求：</strong>与<code>Synchronized</code>在JVM层面上实现的，不但可以通过一些监控工具监控<code>Synchronzied</code>的锁定，而且在代码执行出现异常时，JVM会自动释放锁定；但是使用<code>Lock</code>则不行，<code>Lock</code>时通过代码实现的，要保证锁定一定会被释放，就必须将<code>unLock()</code>放到<code>finally&#123;&#125;</code>中。</li></ol><p>从性能角度，<code>Synchronized</code>早起实现比较低效，对比<code>ReentrantLock</code>，大多数场景性能都相差较大。但是在Java6中对其进行了非常多的改进，在竞争不激烈时，<code>Synchronized</code>的性能要优于<code>ReentrantLock</code>；在搞竞争情况下<code>Synchronized</code>的性能会下降 几十倍，但是<code>ReentrantLock</code>的性能能维持常态。</p><h3 id="ReentrantLock是如何实现可重入性的！"><a href="#ReentrantLock是如何实现可重入性的！" class="headerlink" title="ReentrantLock是如何实现可重入性的！"></a><code>ReentrantLock</code>是如何实现可重入性的！</h3><p><code>ReentrantLock</code>内部自定义了同步器<code>Sync(Synnc及实现了AQS，有实现了AOS，而AOS提供了一种互斥锁持有的方式)</code>，其实就是加锁的时候通过CAS算法，将线程对象放到一个双向链表中，每次获取锁的时候，看下当前维护的那个线程ID和当前请求的线程ID是否一样，一样就重入了。</p><h3 id="除了ReentrantLock，还接触过JUCjava-util-concurrent中的那些并发工具？"><a href="#除了ReentrantLock，还接触过JUCjava-util-concurrent中的那些并发工具？" class="headerlink" title="除了ReentrantLock，还接触过JUCjava.util.concurrent中的那些并发工具？"></a>除了<code>ReentrantLock</code>，还接触过JUC<code>java.util.concurrent</code>中的那些并发工具？</h3><p>通常所说的并发包(JUC)也就是<code>java.util.concurrent</code>及其子包，集中了Java并发的各种基础工具类，具体主要包括几个方面：</p><ul><li>提供了<code>CountDownLatch</code>、<code>CycliBarrier</code>、<code>Semaphore</code>等，比<code>Synchronized</code>更加高级，可以实现更加丰富多线程操作的同步结构。</li><li>提供了<code>ConcurrentHashMap</code>、有序的<code>ConcunrrentSkipListMap</code>或者通过类似快照机制实现线程安全的动态数组<code>CopyOnWriteArrayList</code>等，各种线程安全的容器。</li><li>提供了<code>ArrayBlockingQueue</code>、<code>SynchorousQueue</code>或针对特定场景的<code>PriorityBlockingQueue</code>等，各种并发队列实现。</li><li>强大的<code>Executor</code>框架，可以创建各种不同类型的咸亨吃，调度任务运行等。</li></ul><h3 id="ReadWriteLock和StampedLock"><a href="#ReadWriteLock和StampedLock" class="headerlink" title="ReadWriteLock和StampedLock"></a><code>ReadWriteLock</code>和<code>StampedLock</code></h3><p>虽然<code>ReentrantLock</code>和<code>Synchronized</code>简单实用，但是行为上有一定局限性，要么不占，要么独占。实际应用场景中，有时候不需要大量竞争的写操作，而是以并发读取为主，为了进一步优化并发操作的力度，Java提供了读写锁。</p><p>读写锁基于的原理是多个读操作不需要互斥，如果读锁试图锁定时，写锁是被某个线程持有，读锁将无法获得，而只好等待对象操作结束，这样就可以自动保证不会读取到有争议的数据。</p><p><code>ReadWriteLock</code>代表了一对锁，下面是一个基于读写锁实现的数据结构，当数据量较大，并发读多，并发写少的时候，能够比出同步版本凸显出优势：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RWSample</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Map&lt;String, String&gt; m = <span class="hljs-keyword">new</span> TreeMap&lt;&gt;();<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ReentrantReadWriteLock rwl = <span class="hljs-keyword">new</span> ReentrantReadWriteLock();<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Lock r = rwl.readLock();<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Lock w = rwl.writeLock();<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">get</span><span class="hljs-params">(String key)</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;读锁锁定!&quot;</span>);<br>        <span class="hljs-keyword">try</span>&#123;<br>            <span class="hljs-keyword">return</span> m.get(key);<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            r.unlock();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">put</span><span class="hljs-params">(String key, String entry)</span></span>&#123;<br>        w.lock();;<br>        System.out.println(<span class="hljs-string">&quot;写锁锁定!&quot;</span>);<br>        <span class="hljs-keyword">try</span>&#123;<br>            <span class="hljs-keyword">return</span> m.put(key, entry);<br>        &#125;  <span class="hljs-keyword">finally</span> &#123;<br>            w.unlock();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>读写锁看起来比<code>Synchronized</code>的粒度似乎细一些，但在实际应用中，其表现也并不尽如人意 ，主要还是因为 相对比较大的恶开销。随意JDK在后期引入了 <code>StampedLock</code>，在提供类似读写锁的同时，还支持优化读模式。大多数情况下读操作并不会和写操作冲突，其逻辑是先试着修改，然后通过<code>validate</code>方法确认是否进入了写模式，如果没有进入，就成功 避免了开销；如果进入，则尝试 获取读锁。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StampedSample</span></span>&#123;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> StampedLock sl = <span class="hljs-keyword">new</span> StampedLock();<br>  <br>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">mutate</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">long</span> stamp = sl.writeLock();<br>    <span class="hljs-keyword">try</span>&#123;<br>      write();<br>    &#125; <span class="hljs-keyword">finally</span>&#123;<br>      sl.unlockWrite();<br>    &#125;<br>  &#125;<br>  <span class="hljs-function">Data <span class="hljs-title">access</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">long</span> stamp = sl.tryOptimisticRead();<br>    Data data = read();<br>    <span class="hljs-keyword">if</span>(!sl.validate(stamp))&#123;<br>      stamp = sk.readLock();<br>      <span class="hljs-keyword">try</span>&#123;<br>        data = read();<br>      &#125; <span class="hljs-keyword">finally</span>&#123;<br>        sl.unlockRead();<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> data;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
